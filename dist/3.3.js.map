{"version":3,"sources":["webpack:///3.3.js","webpack:///./src/js/jquery.fileupload.js","webpack:///./src/js/vendor/jquery.ui.widget.js"],"names":["webpackJsonp","188","module","exports","__webpack_require__","_typeof","Symbol","iterator","obj","constructor","factory","window","jQuery","$","getDragHandler","type","isDragOver","e","dataTransfer","originalEvent","inArray","types","this","_trigger","Event","delegatedEvent","preventDefault","dropEffect","support","fileInput","RegExp","test","navigator","userAgent","prop","xhrFileUpload","ProgressEvent","FileReader","xhrFormDataFileUpload","FormData","blobSlice","Blob","prototype","slice","webkitSlice","mozSlice","widget","options","dropZone","document","pasteZone","undefined","replaceFileInput","paramName","singleFileUploads","limitMultiFileUploads","limitMultiFileUploadSize","limitMultiFileUploadSizeOverhead","sequentialUploads","limitConcurrentUploads","forceIframeTransport","redirect","redirectParamName","postMessage","multipart","maxChunkSize","uploadedBytes","recalculateProgress","progressInterval","bitrateInterval","autoUpload","messages","i18n","message","context","toString","each","key","value","replace","formData","form","serializeArray","add","data","isDefaultPrevented","fileupload","process","done","submit","processData","contentType","cache","timeout","_specialOptions","_blobSlice","apply","arguments","_BitrateTimer","timestamp","Date","now","getTime","loaded","bitrate","getBitrate","interval","timeDiff","_isXHRUpload","_getFormData","isArray","name","push","_getTotal","files","total","index","file","size","_initProgressObject","progress","_progress","extend","_initResponseObject","_response","hasOwnProperty","_onProgress","lengthComputable","_time","Math","floor","chunkSize","_bitrateTimer","_initProgressListener","that","xhr","ajaxSettings","upload","bind","oe","_isInstanceOf","Object","call","_initXHRData","headers","contentRange","blob","encodeURI","field","append","uploadName","_initIframeSettings","targetHost","url","dataType","location","host","_initDataSettings","_chunkedUpload","_getParamName","input","i","length","_initFormSettings","href","toUpperCase","formAcceptCharset","attr","_getAJAXSettings","_getDeferredState","deferred","state","isResolved","isRejected","_enhancePromise","promise","success","error","fail","complete","always","_getXHRPromise","resolveOrReject","args","dfd","Deferred","resolveWith","rejectWith","abort","_addConvenienceMethods","getPromise","resolveFunc","rejectFunc","_processQueue","then","errorThrown","jqXHR","_onSend","processing","response","_getUploadedBytes","range","getResponseHeader","parts","split","upperBytesPos","parseInt","testOnly","fs","ub","mcs","o","currentLoaded","ajax","result","textStatus","_beforeSend","_active","_onDone","_onFail","_onAlways","jqXHRorResult","jqXHRorError","aborted","slot","pipe","send","_sending","nextSlot","_slots","shift","resolve","_sequence","_onAdd","paramNameSet","paramNameSlice","fileSet","filesLength","limit","limitSize","overhead","batchSize","j","originalFiles","element","newData","_replaceFileInput","inputClone","clone","restoreFocus","is","activeElement","fileInputClone","reset","after","detach","focus","cleanData","unbind","map","el","_handleFileTreeEntry","entry","path","dirReader","errorHandler","successHandler","entries","_handleFileTreeEntries","readEntries","results","concat","isFile","_file","relativePath","isDirectory","createReader","when","Array","_getDroppedFiles","items","webkitGetAsEntry","getAsEntry","item","getAsFile","makeArray","_getSingleFileInputFiles","fileName","fileSize","_getFileInputFiles","_onChange","target","_onPaste","clipboardData","_onDrop","_onDragOver","_onDragEnter","_onDragLeave","_initEventHandlers","_on","dragover","drop","dragenter","dragleave","paste","change","_destroyEventHandlers","_off","_setOption","reinit","_super","_initSpecialOptions","find","_getRegExp","str","modifiers","pop","join","_isRegExpOption","_initDataAttributes","attributes","toLowerCase","charAt","_create","active","disabled","reject","189","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","widget_uuid","widget_slice","orig","elems","events","elem","_data","remove","triggerHandler","base","fullName","existingConstructor","basePrototype","proxiedPrototype","namespace","Widget","expr","_createWidget","version","_proto","_childConstructors","isFunction","_superApply","returnValue","__super","__superApply","widgetEventPrefix","widgetName","widgetFullName","child","childPrototype","bridge","inputIndex","inputLength","isPlainObject","object","fn","isMethodCall","methodValue","instance","jquery","pushStack","get","option","_init","defaultElement","create","uuid","eventNamespace","bindings","hoverable","focusable","event","destroy","style","ownerDocument","defaultView","parentWindow","_getCreateOptions","_getCreateEventData","noop","_destroy","removeData","camelCase","removeAttr","removeClass","curOption","_setOptions","toggleClass","enable","disable","suppressDisabledCheck","handlers","delegateElement","handler","handlerProxy","hasClass","guid","match","eventName","selector","delegate","undelegate","not","_delay","delay","setTimeout","_hoverable","mouseenter","currentTarget","addClass","mouseleave","_focusable","focusin","focusout","callback","trigger","show","hide","method","defaultEffect","effect","hasOptions","effectName","duration","isEmptyObject","effects","easing","queue","next"],"mappings":"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","file":"3.3.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 188:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*\n\t * jQuery File Upload Plugin\n\t * https://github.com/blueimp/jQuery-File-Upload\n\t *\n\t * Copyright 2010, Sebastian Tschan\n\t * https://blueimp.net\n\t *\n\t * Licensed under the MIT license:\n\t * http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* jshint nomen:false */\n\t/* global define, require, window, document, location, Blob, FormData */\n\t\n\t;(function (factory) {\n\t    'use strict';\n\t    //if (typeof define === 'function' && define.amd) {\n\t    //    // Register as an anonymous AMD module:\n\t    //    define([\n\t    //        'jquery',\n\t    //        'jquery.ui.widget'\n\t    //    ], factory);\n\t    //} else\n\t\n\t    if (( false ? 'undefined' : _typeof(exports)) === 'object') {\n\t        // Node/CommonJS:\n\t        factory(__webpack_require__(6), __webpack_require__(189));\n\t    } else {\n\t        // Browser globals:\n\t        factory(window.jQuery);\n\t    }\n\t})(function ($) {\n\t    'use strict';\n\t\n\t    // Detect file input support, based on\n\t    // http://viljamis.com/blog/2012/file-upload-support-on-mobile/\n\t\n\t    $.support.fileInput = !(new RegExp(\n\t    // Handle devices which give false positives for the feature detection:\n\t    '(Android (1\\\\.[0156]|2\\\\.[01]))' + '|(Windows Phone (OS 7|8\\\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' + '|(w(eb)?OSBrowser)|(webOS)' + '|(Kindle/(1\\\\.0|2\\\\.[05]|3\\\\.0))').test(window.navigator.userAgent) ||\n\t    // Feature detection for all other devices:\n\t    $('<input type=\"file\">').prop('disabled'));\n\t\n\t    // The FileReader API is not actually used, but works as feature detection,\n\t    // as some Safari versions (5?) support XHR file uploads via the FormData API,\n\t    // but not non-multipart XHR file uploads.\n\t    // window.XMLHttpRequestUpload is not available on IE10, so we check for\n\t    // window.ProgressEvent instead to detect XHR2 file upload capability:\n\t    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\n\t    $.support.xhrFormDataFileUpload = !!window.FormData;\n\t\n\t    // Detect support for Blob slicing (required for chunked uploads):\n\t    $.support.blobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n\t\n\t    // Helper function to create drag handlers for dragover/dragenter/dragleave:\n\t    function getDragHandler(type) {\n\t        var isDragOver = type === 'dragover';\n\t        return function (e) {\n\t            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\n\t            var dataTransfer = e.dataTransfer;\n\t            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 && this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false) {\n\t                e.preventDefault();\n\t                if (isDragOver) {\n\t                    dataTransfer.dropEffect = 'copy';\n\t                }\n\t            }\n\t        };\n\t    }\n\t\n\t    // The fileupload widget listens for change events on file input fields defined\n\t    // via fileInput setting and paste or drop events of the given dropZone.\n\t    // In addition to the default jQuery Widget methods, the fileupload widget\n\t    // exposes the \"add\" and \"send\" methods, to add or directly send files using\n\t    // the fileupload API.\n\t    // By default, files added via file input selection, paste, drag & drop or\n\t    // \"add\" method are uploaded immediately, but it is possible to override\n\t    // the \"add\" callback option to queue file uploads.\n\t    $.widget('blueimp.fileupload', {\n\t\n\t        options: {\n\t            // The drop target element(s), by the default the complete document.\n\t            // Set to null to disable drag & drop support:\n\t            dropZone: $(document),\n\t            // The paste target element(s), by the default undefined.\n\t            // Set to a DOM node or jQuery object to enable file pasting:\n\t            pasteZone: undefined,\n\t            // The file input field(s), that are listened to for change events.\n\t            // If undefined, it is set to the file input fields inside\n\t            // of the widget element on plugin initialization.\n\t            // Set to null to disable the change listener.\n\t            fileInput: undefined,\n\t            // By default, the file input field is replaced with a clone after\n\t            // each input field change event. This is required for iframe transport\n\t            // queues and allows change events to be fired for the same file\n\t            // selection, but can be disabled by setting the following option to false:\n\t            replaceFileInput: true,\n\t            // The parameter name for the file form data (the request argument name).\n\t            // If undefined or empty, the name property of the file input field is\n\t            // used, or \"files[]\" if the file input name property is also empty,\n\t            // can be a string or an array of strings:\n\t            paramName: undefined,\n\t            // By default, each file of a selection is uploaded using an individual\n\t            // request for XHR type uploads. Set to false to upload file\n\t            // selections in one request each:\n\t            singleFileUploads: true,\n\t            // To limit the number of files uploaded with one XHR request,\n\t            // set the following option to an integer greater than 0:\n\t            limitMultiFileUploads: undefined,\n\t            // The following option limits the number of files uploaded with one\n\t            // XHR request to keep the request size under or equal to the defined\n\t            // limit in bytes:\n\t            limitMultiFileUploadSize: undefined,\n\t            // Multipart file uploads add a number of bytes to each uploaded file,\n\t            // therefore the following option adds an overhead for each file used\n\t            // in the limitMultiFileUploadSize configuration:\n\t            limitMultiFileUploadSizeOverhead: 512,\n\t            // Set the following option to true to issue all file upload requests\n\t            // in a sequential order:\n\t            sequentialUploads: false,\n\t            // To limit the number of concurrent uploads,\n\t            // set the following option to an integer greater than 0:\n\t            limitConcurrentUploads: undefined,\n\t            // Set the following option to true to force iframe transport uploads:\n\t            forceIframeTransport: false,\n\t            // Set the following option to the location of a redirect url on the\n\t            // origin server, for cross-domain iframe transport uploads:\n\t            redirect: undefined,\n\t            // The parameter name for the redirect url, sent as part of the form\n\t            // data and set to 'redirect' if this option is empty:\n\t            redirectParamName: undefined,\n\t            // Set the following option to the location of a postMessage window,\n\t            // to enable postMessage transport uploads:\n\t            postMessage: undefined,\n\t            // By default, XHR file uploads are sent as multipart/form-data.\n\t            // The iframe transport is always using multipart/form-data.\n\t            // Set to false to enable non-multipart XHR uploads:\n\t            multipart: true,\n\t            // To upload large files in smaller chunks, set the following option\n\t            // to a preferred maximum chunk size. If set to 0, null or undefined,\n\t            // or the browser does not support the required Blob API, files will\n\t            // be uploaded as a whole.\n\t            maxChunkSize: undefined,\n\t            // When a non-multipart upload or a chunked multipart upload has been\n\t            // aborted, this option can be used to resume the upload by setting\n\t            // it to the size of the already uploaded bytes. This option is most\n\t            // useful when modifying the options object inside of the \"add\" or\n\t            // \"send\" callbacks, as the options are cloned for each file upload.\n\t            uploadedBytes: undefined,\n\t            // By default, failed (abort or error) file uploads are removed from the\n\t            // global progress calculation. Set the following option to false to\n\t            // prevent recalculating the global progress data:\n\t            recalculateProgress: true,\n\t            // Interval in milliseconds to calculate and trigger progress events:\n\t            progressInterval: 100,\n\t            // Interval in milliseconds to calculate progress bitrate:\n\t            bitrateInterval: 500,\n\t            // By default, uploads are started automatically when adding files:\n\t            autoUpload: true,\n\t\n\t            // Error and info messages:\n\t            messages: {\n\t                uploadedBytes: 'Uploaded bytes exceed file size'\n\t            },\n\t\n\t            // Translation function, gets the message key to be translated\n\t            // and an object with context specific data as arguments:\n\t            i18n: function i18n(message, context) {\n\t                message = this.messages[message] || message.toString();\n\t                if (context) {\n\t                    $.each(context, function (key, value) {\n\t                        message = message.replace('{' + key + '}', value);\n\t                    });\n\t                }\n\t                return message;\n\t            },\n\t\n\t            // Additional form data to be sent along with the file uploads can be set\n\t            // using this option, which accepts an array of objects with name and\n\t            // value properties, a function returning such an array, a FormData\n\t            // object (for XHR file uploads), or a simple object.\n\t            // The form of the first fileInput is given as parameter to the function:\n\t            formData: function formData(form) {\n\t                return form.serializeArray();\n\t            },\n\t\n\t            // The add callback is invoked as soon as files are added to the fileupload\n\t            // widget (via file input selection, drag & drop, paste or add API call).\n\t            // If the singleFileUploads option is enabled, this callback will be\n\t            // called once for each file in the selection for XHR file uploads, else\n\t            // once for each file selection.\n\t            //\n\t            // The upload starts when the submit method is invoked on the data parameter.\n\t            // The data object contains a files property holding the added files\n\t            // and allows you to override plugin options as well as define ajax settings.\n\t            //\n\t            // Listeners for this callback can also be bound the following way:\n\t            // .bind('fileuploadadd', func);\n\t            //\n\t            // data.submit() returns a Promise object and allows to attach additional\n\t            // handlers using jQuery's Deferred callbacks:\n\t            // data.submit().done(func).fail(func).always(func);\n\t            add: function add(e, data) {\n\t                if (e.isDefaultPrevented()) {\n\t                    return false;\n\t                }\n\t                if (data.autoUpload || data.autoUpload !== false && $(this).fileupload('option', 'autoUpload')) {\n\t                    data.process().done(function () {\n\t                        data.submit();\n\t                    });\n\t                }\n\t            },\n\t\n\t            // Other callbacks:\n\t\n\t            // Callback for the submit event of each file upload:\n\t            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\n\t\n\t            // Callback for the start of each file upload request:\n\t            // send: function (e, data) {}, // .bind('fileuploadsend', func);\n\t\n\t            // Callback for successful uploads:\n\t            // done: function (e, data) {}, // .bind('fileuploaddone', func);\n\t\n\t            // Callback for failed (abort or error) uploads:\n\t            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\n\t\n\t            // Callback for completed (success, abort or error) requests:\n\t            // always: function (e, data) {}, // .bind('fileuploadalways', func);\n\t\n\t            // Callback for upload progress events:\n\t            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\n\t\n\t            // Callback for global upload progress events:\n\t            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\n\t\n\t            // Callback for uploads start, equivalent to the global ajaxStart event:\n\t            // start: function (e) {}, // .bind('fileuploadstart', func);\n\t\n\t            // Callback for uploads stop, equivalent to the global ajaxStop event:\n\t            // stop: function (e) {}, // .bind('fileuploadstop', func);\n\t\n\t            // Callback for change events of the fileInput(s):\n\t            // change: function (e, data) {}, // .bind('fileuploadchange', func);\n\t\n\t            // Callback for paste events to the pasteZone(s):\n\t            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\n\t\n\t            // Callback for drop events of the dropZone(s):\n\t            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\n\t\n\t            // Callback for dragover events of the dropZone(s):\n\t            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\n\t\n\t            // Callback for the start of each chunk upload request:\n\t            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\n\t\n\t            // Callback for successful chunk uploads:\n\t            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\n\t\n\t            // Callback for failed (abort or error) chunk uploads:\n\t            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\n\t\n\t            // Callback for completed (success, abort or error) chunk upload requests:\n\t            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\n\t\n\t            // The plugin options are used as settings object for the ajax calls.\n\t            // The following are jQuery ajax settings required for the file uploads:\n\t            processData: false,\n\t            contentType: false,\n\t            cache: false,\n\t            timeout: 0\n\t        },\n\t\n\t        // A list of options that require reinitializing event listeners and/or\n\t        // special initialization code:\n\t        _specialOptions: ['fileInput', 'dropZone', 'pasteZone', 'multipart', 'forceIframeTransport'],\n\t\n\t        _blobSlice: $.support.blobSlice && function () {\n\t            var slice = this.slice || this.webkitSlice || this.mozSlice;\n\t            return slice.apply(this, arguments);\n\t        },\n\t\n\t        _BitrateTimer: function _BitrateTimer() {\n\t            this.timestamp = Date.now ? Date.now() : new Date().getTime();\n\t            this.loaded = 0;\n\t            this.bitrate = 0;\n\t            this.getBitrate = function (now, loaded, interval) {\n\t                var timeDiff = now - this.timestamp;\n\t                if (!this.bitrate || !interval || timeDiff > interval) {\n\t                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\n\t                    this.loaded = loaded;\n\t                    this.timestamp = now;\n\t                }\n\t                return this.bitrate;\n\t            };\n\t        },\n\t\n\t        _isXHRUpload: function _isXHRUpload(options) {\n\t            return !options.forceIframeTransport && (!options.multipart && $.support.xhrFileUpload || $.support.xhrFormDataFileUpload);\n\t        },\n\t\n\t        _getFormData: function _getFormData(options) {\n\t            var formData;\n\t            if ($.type(options.formData) === 'function') {\n\t                return options.formData(options.form);\n\t            }\n\t            if ($.isArray(options.formData)) {\n\t                return options.formData;\n\t            }\n\t            if ($.type(options.formData) === 'object') {\n\t                formData = [];\n\t                $.each(options.formData, function (name, value) {\n\t                    formData.push({ name: name, value: value });\n\t                });\n\t                return formData;\n\t            }\n\t            return [];\n\t        },\n\t\n\t        _getTotal: function _getTotal(files) {\n\t            var total = 0;\n\t            $.each(files, function (index, file) {\n\t                total += file.size || 1;\n\t            });\n\t            return total;\n\t        },\n\t\n\t        _initProgressObject: function _initProgressObject(obj) {\n\t            var progress = {\n\t                loaded: 0,\n\t                total: 0,\n\t                bitrate: 0\n\t            };\n\t            if (obj._progress) {\n\t                $.extend(obj._progress, progress);\n\t            } else {\n\t                obj._progress = progress;\n\t            }\n\t        },\n\t\n\t        _initResponseObject: function _initResponseObject(obj) {\n\t            var prop;\n\t            if (obj._response) {\n\t                for (prop in obj._response) {\n\t                    if (obj._response.hasOwnProperty(prop)) {\n\t                        delete obj._response[prop];\n\t                    }\n\t                }\n\t            } else {\n\t                obj._response = {};\n\t            }\n\t        },\n\t\n\t        _onProgress: function _onProgress(e, data) {\n\t            if (e.lengthComputable) {\n\t                var now = Date.now ? Date.now() : new Date().getTime(),\n\t                    loaded;\n\t                if (data._time && data.progressInterval && now - data._time < data.progressInterval && e.loaded !== e.total) {\n\t                    return;\n\t                }\n\t                data._time = now;\n\t                loaded = Math.floor(e.loaded / e.total * (data.chunkSize || data._progress.total)) + (data.uploadedBytes || 0);\n\t                // Add the difference from the previously loaded state\n\t                // to the global loaded counter:\n\t                this._progress.loaded += loaded - data._progress.loaded;\n\t                this._progress.bitrate = this._bitrateTimer.getBitrate(now, this._progress.loaded, data.bitrateInterval);\n\t                data._progress.loaded = data.loaded = loaded;\n\t                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(now, loaded, data.bitrateInterval);\n\t                // Trigger a custom progress event with a total data property set\n\t                // to the file size(s) of the current upload and a loaded data\n\t                // property calculated accordingly:\n\t                this._trigger('progress', $.Event('progress', { delegatedEvent: e }), data);\n\t                // Trigger a global progress event for all current file uploads,\n\t                // including ajax calls queued for sequential file uploads:\n\t                this._trigger('progressall', $.Event('progressall', { delegatedEvent: e }), this._progress);\n\t            }\n\t        },\n\t\n\t        _initProgressListener: function _initProgressListener(options) {\n\t            var that = this,\n\t                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\n\t            // Accesss to the native XHR object is required to add event listeners\n\t            // for the upload progress event:\n\t            if (xhr.upload) {\n\t                $(xhr.upload).bind('progress', function (e) {\n\t                    var oe = e.originalEvent;\n\t                    // Make sure the progress event properties get copied over:\n\t                    e.lengthComputable = oe.lengthComputable;\n\t                    e.loaded = oe.loaded;\n\t                    e.total = oe.total;\n\t                    that._onProgress(e, options);\n\t                });\n\t                options.xhr = function () {\n\t                    return xhr;\n\t                };\n\t            }\n\t        },\n\t\n\t        _isInstanceOf: function _isInstanceOf(type, obj) {\n\t            // Cross-frame instanceof check\n\t            return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n\t        },\n\t\n\t        _initXHRData: function _initXHRData(options) {\n\t            var that = this,\n\t                formData,\n\t                file = options.files[0],\n\t\n\t            // Ignore non-multipart setting if not supported:\n\t            multipart = options.multipart || !$.support.xhrFileUpload,\n\t                paramName = $.type(options.paramName) === 'array' ? options.paramName[0] : options.paramName;\n\t            options.headers = $.extend({}, options.headers);\n\t            if (options.contentRange) {\n\t                options.headers['Content-Range'] = options.contentRange;\n\t            }\n\t            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\n\t                options.headers['Content-Disposition'] = 'attachment; filename=\"' + encodeURI(file.name) + '\"';\n\t            }\n\t            if (!multipart) {\n\t                options.contentType = file.type || 'application/octet-stream';\n\t                options.data = options.blob || file;\n\t            } else if ($.support.xhrFormDataFileUpload) {\n\t                if (options.postMessage) {\n\t                    // window.postMessage does not allow sending FormData\n\t                    // objects, so we just add the File/Blob objects to\n\t                    // the formData array and let the postMessage window\n\t                    // create the FormData object out of this array:\n\t                    formData = this._getFormData(options);\n\t                    if (options.blob) {\n\t                        formData.push({\n\t                            name: paramName,\n\t                            value: options.blob\n\t                        });\n\t                    } else {\n\t                        $.each(options.files, function (index, file) {\n\t                            formData.push({\n\t                                name: $.type(options.paramName) === 'array' && options.paramName[index] || paramName,\n\t                                value: file\n\t                            });\n\t                        });\n\t                    }\n\t                } else {\n\t                    if (that._isInstanceOf('FormData', options.formData)) {\n\t                        formData = options.formData;\n\t                    } else {\n\t                        formData = new FormData();\n\t                        $.each(this._getFormData(options), function (index, field) {\n\t                            formData.append(field.name, field.value);\n\t                        });\n\t                    }\n\t                    if (options.blob) {\n\t                        formData.append(paramName, options.blob, file.name);\n\t                    } else {\n\t                        $.each(options.files, function (index, file) {\n\t                            // This check allows the tests to run with\n\t                            // dummy objects:\n\t                            if (that._isInstanceOf('File', file) || that._isInstanceOf('Blob', file)) {\n\t                                formData.append($.type(options.paramName) === 'array' && options.paramName[index] || paramName, file, file.uploadName || file.name);\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t                options.data = formData;\n\t            }\n\t            // Blob reference is not needed anymore, free memory:\n\t            options.blob = null;\n\t        },\n\t\n\t        _initIframeSettings: function _initIframeSettings(options) {\n\t            var targetHost = $('<a></a>').prop('href', options.url).prop('host');\n\t            // Setting the dataType to iframe enables the iframe transport:\n\t            options.dataType = 'iframe ' + (options.dataType || '');\n\t            // The iframe transport accepts a serialized array as form data:\n\t            options.formData = this._getFormData(options);\n\t            // Add redirect url to form data on cross-domain uploads:\n\t            if (options.redirect && targetHost && targetHost !== location.host) {\n\t                options.formData.push({\n\t                    name: options.redirectParamName || 'redirect',\n\t                    value: options.redirect\n\t                });\n\t            }\n\t        },\n\t\n\t        _initDataSettings: function _initDataSettings(options) {\n\t            if (this._isXHRUpload(options)) {\n\t                if (!this._chunkedUpload(options, true)) {\n\t                    if (!options.data) {\n\t                        this._initXHRData(options);\n\t                    }\n\t                    this._initProgressListener(options);\n\t                }\n\t                if (options.postMessage) {\n\t                    // Setting the dataType to postmessage enables the\n\t                    // postMessage transport:\n\t                    options.dataType = 'postmessage ' + (options.dataType || '');\n\t                }\n\t            } else {\n\t                this._initIframeSettings(options);\n\t            }\n\t        },\n\t\n\t        _getParamName: function _getParamName(options) {\n\t            var fileInput = $(options.fileInput),\n\t                paramName = options.paramName;\n\t            if (!paramName) {\n\t                paramName = [];\n\t                fileInput.each(function () {\n\t                    var input = $(this),\n\t                        name = input.prop('name') || 'files[]',\n\t                        i = (input.prop('files') || [1]).length;\n\t                    while (i) {\n\t                        paramName.push(name);\n\t                        i -= 1;\n\t                    }\n\t                });\n\t                if (!paramName.length) {\n\t                    paramName = [fileInput.prop('name') || 'files[]'];\n\t                }\n\t            } else if (!$.isArray(paramName)) {\n\t                paramName = [paramName];\n\t            }\n\t            return paramName;\n\t        },\n\t\n\t        _initFormSettings: function _initFormSettings(options) {\n\t            // Retrieve missing options from the input field and the\n\t            // associated form, if available:\n\t            if (!options.form || !options.form.length) {\n\t                options.form = $(options.fileInput.prop('form'));\n\t                // If the given file input doesn't have an associated form,\n\t                // use the default widget file input's form:\n\t                if (!options.form.length) {\n\t                    options.form = $(this.options.fileInput.prop('form'));\n\t                }\n\t            }\n\t            options.paramName = this._getParamName(options);\n\t            if (!options.url) {\n\t                options.url = options.form.prop('action') || location.href;\n\t            }\n\t            // The HTTP request method must be \"POST\" or \"PUT\":\n\t            options.type = (options.type || $.type(options.form.prop('method')) === 'string' && options.form.prop('method') || '').toUpperCase();\n\t            if (options.type !== 'POST' && options.type !== 'PUT' && options.type !== 'PATCH') {\n\t                options.type = 'POST';\n\t            }\n\t            if (!options.formAcceptCharset) {\n\t                options.formAcceptCharset = options.form.attr('accept-charset');\n\t            }\n\t        },\n\t\n\t        _getAJAXSettings: function _getAJAXSettings(data) {\n\t            var options = $.extend({}, this.options, data);\n\t            this._initFormSettings(options);\n\t            this._initDataSettings(options);\n\t            return options;\n\t        },\n\t\n\t        // jQuery 1.6 doesn't provide .state(),\n\t        // while jQuery 1.8+ removed .isRejected() and .isResolved():\n\t        _getDeferredState: function _getDeferredState(deferred) {\n\t            if (deferred.state) {\n\t                return deferred.state();\n\t            }\n\t            if (deferred.isResolved()) {\n\t                return 'resolved';\n\t            }\n\t            if (deferred.isRejected()) {\n\t                return 'rejected';\n\t            }\n\t            return 'pending';\n\t        },\n\t\n\t        // Maps jqXHR callbacks to the equivalent\n\t        // methods of the given Promise object:\n\t        _enhancePromise: function _enhancePromise(promise) {\n\t            promise.success = promise.done;\n\t            promise.error = promise.fail;\n\t            promise.complete = promise.always;\n\t            return promise;\n\t        },\n\t\n\t        // Creates and returns a Promise object enhanced with\n\t        // the jqXHR methods abort, success, error and complete:\n\t        _getXHRPromise: function _getXHRPromise(resolveOrReject, context, args) {\n\t            var dfd = $.Deferred(),\n\t                promise = dfd.promise();\n\t            context = context || this.options.context || promise;\n\t            if (resolveOrReject === true) {\n\t                dfd.resolveWith(context, args);\n\t            } else if (resolveOrReject === false) {\n\t                dfd.rejectWith(context, args);\n\t            }\n\t            promise.abort = dfd.promise;\n\t            return this._enhancePromise(promise);\n\t        },\n\t\n\t        // Adds convenience methods to the data callback argument:\n\t        _addConvenienceMethods: function _addConvenienceMethods(e, data) {\n\t            var that = this,\n\t                getPromise = function getPromise(args) {\n\t                return $.Deferred().resolveWith(that, args).promise();\n\t            };\n\t            data.process = function (resolveFunc, rejectFunc) {\n\t                if (resolveFunc || rejectFunc) {\n\t                    data._processQueue = this._processQueue = (this._processQueue || getPromise([this])).then(function () {\n\t                        if (data.errorThrown) {\n\t                            return $.Deferred().rejectWith(that, [data]).promise();\n\t                        }\n\t                        return getPromise(arguments);\n\t                    }).then(resolveFunc, rejectFunc);\n\t                }\n\t                return this._processQueue || getPromise([this]);\n\t            };\n\t            data.submit = function () {\n\t                if (this.state() !== 'pending') {\n\t                    data.jqXHR = this.jqXHR = that._trigger('submit', $.Event('submit', { delegatedEvent: e }), this) !== false && that._onSend(e, this);\n\t                }\n\t                return this.jqXHR || that._getXHRPromise();\n\t            };\n\t            data.abort = function () {\n\t                if (this.jqXHR) {\n\t                    return this.jqXHR.abort();\n\t                }\n\t                this.errorThrown = 'abort';\n\t                that._trigger('fail', null, this);\n\t                return that._getXHRPromise(false);\n\t            };\n\t            data.state = function () {\n\t                if (this.jqXHR) {\n\t                    return that._getDeferredState(this.jqXHR);\n\t                }\n\t                if (this._processQueue) {\n\t                    return that._getDeferredState(this._processQueue);\n\t                }\n\t            };\n\t            data.processing = function () {\n\t                return !this.jqXHR && this._processQueue && that._getDeferredState(this._processQueue) === 'pending';\n\t            };\n\t            data.progress = function () {\n\t                return this._progress;\n\t            };\n\t            data.response = function () {\n\t                return this._response;\n\t            };\n\t        },\n\t\n\t        // Parses the Range header from the server response\n\t        // and returns the uploaded bytes:\n\t        _getUploadedBytes: function _getUploadedBytes(jqXHR) {\n\t            var range = jqXHR.getResponseHeader('Range'),\n\t                parts = range && range.split('-'),\n\t                upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);\n\t            return upperBytesPos && upperBytesPos + 1;\n\t        },\n\t\n\t        // Uploads a file in multiple, sequential requests\n\t        // by splitting the file up in multiple blob chunks.\n\t        // If the second parameter is true, only tests if the file\n\t        // should be uploaded in chunks, but does not invoke any\n\t        // upload requests:\n\t        _chunkedUpload: function _chunkedUpload(options, testOnly) {\n\t            options.uploadedBytes = options.uploadedBytes || 0;\n\t            var that = this,\n\t                file = options.files[0],\n\t                fs = file.size,\n\t                ub = options.uploadedBytes,\n\t                mcs = options.maxChunkSize || fs,\n\t                slice = this._blobSlice,\n\t                dfd = $.Deferred(),\n\t                promise = dfd.promise(),\n\t                jqXHR,\n\t                _upload;\n\t            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) || options.data) {\n\t                return false;\n\t            }\n\t            if (testOnly) {\n\t                return true;\n\t            }\n\t            if (ub >= fs) {\n\t                file.error = options.i18n('uploadedBytes');\n\t                return this._getXHRPromise(false, options.context, [null, 'error', file.error]);\n\t            }\n\t            // The chunk upload method:\n\t            _upload = function upload() {\n\t                // Clone the options object for each chunk upload:\n\t                var o = $.extend({}, options),\n\t                    currentLoaded = o._progress.loaded;\n\t                o.blob = slice.call(file, ub, ub + mcs, file.type);\n\t                // Store the current chunk size, as the blob itself\n\t                // will be dereferenced after data processing:\n\t                o.chunkSize = o.blob.size;\n\t                // Expose the chunk bytes position range:\n\t                o.contentRange = 'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;\n\t                // Process the upload data (the blob and potential form data):\n\t                that._initXHRData(o);\n\t                // Add progress listeners for this chunk upload:\n\t                that._initProgressListener(o);\n\t                jqXHR = (that._trigger('chunksend', null, o) !== false && $.ajax(o) || that._getXHRPromise(false, o.context)).done(function (result, textStatus, jqXHR) {\n\t                    ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;\n\t                    // Create a progress event if no final progress event\n\t                    // with loaded equaling total has been triggered\n\t                    // for this chunk:\n\t                    if (currentLoaded + o.chunkSize - o._progress.loaded) {\n\t                        that._onProgress($.Event('progress', {\n\t                            lengthComputable: true,\n\t                            loaded: ub - o.uploadedBytes,\n\t                            total: ub - o.uploadedBytes\n\t                        }), o);\n\t                    }\n\t                    options.uploadedBytes = o.uploadedBytes = ub;\n\t                    o.result = result;\n\t                    o.textStatus = textStatus;\n\t                    o.jqXHR = jqXHR;\n\t                    that._trigger('chunkdone', null, o);\n\t                    that._trigger('chunkalways', null, o);\n\t                    if (ub < fs) {\n\t                        // File upload not yet complete,\n\t                        // continue with the next chunk:\n\t                        _upload();\n\t                    } else {\n\t                        dfd.resolveWith(o.context, [result, textStatus, jqXHR]);\n\t                    }\n\t                }).fail(function (jqXHR, textStatus, errorThrown) {\n\t                    o.jqXHR = jqXHR;\n\t                    o.textStatus = textStatus;\n\t                    o.errorThrown = errorThrown;\n\t                    that._trigger('chunkfail', null, o);\n\t                    that._trigger('chunkalways', null, o);\n\t                    dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);\n\t                });\n\t            };\n\t            this._enhancePromise(promise);\n\t            promise.abort = function () {\n\t                return jqXHR.abort();\n\t            };\n\t            _upload();\n\t            return promise;\n\t        },\n\t\n\t        _beforeSend: function _beforeSend(e, data) {\n\t            if (this._active === 0) {\n\t                // the start callback is triggered when an upload starts\n\t                // and no other uploads are currently running,\n\t                // equivalent to the global ajaxStart event:\n\t                this._trigger('start');\n\t                // Set timer for global bitrate progress calculation:\n\t                this._bitrateTimer = new this._BitrateTimer();\n\t                // Reset the global progress values:\n\t                this._progress.loaded = this._progress.total = 0;\n\t                this._progress.bitrate = 0;\n\t            }\n\t            // Make sure the container objects for the .response() and\n\t            // .progress() methods on the data object are available\n\t            // and reset to their initial state:\n\t            this._initResponseObject(data);\n\t            this._initProgressObject(data);\n\t            data._progress.loaded = data.loaded = data.uploadedBytes || 0;\n\t            data._progress.total = data.total = this._getTotal(data.files) || 1;\n\t            data._progress.bitrate = data.bitrate = 0;\n\t            this._active += 1;\n\t            // Initialize the global progress values:\n\t            this._progress.loaded += data.loaded;\n\t            this._progress.total += data.total;\n\t        },\n\t\n\t        _onDone: function _onDone(result, textStatus, jqXHR, options) {\n\t            var total = options._progress.total,\n\t                response = options._response;\n\t            if (options._progress.loaded < total) {\n\t                // Create a progress event if no final progress event\n\t                // with loaded equaling total has been triggered:\n\t                this._onProgress($.Event('progress', {\n\t                    lengthComputable: true,\n\t                    loaded: total,\n\t                    total: total\n\t                }), options);\n\t            }\n\t            response.result = options.result = result;\n\t            response.textStatus = options.textStatus = textStatus;\n\t            response.jqXHR = options.jqXHR = jqXHR;\n\t            this._trigger('done', null, options);\n\t        },\n\t\n\t        _onFail: function _onFail(jqXHR, textStatus, errorThrown, options) {\n\t            var response = options._response;\n\t            if (options.recalculateProgress) {\n\t                // Remove the failed (error or abort) file upload from\n\t                // the global progress calculation:\n\t                this._progress.loaded -= options._progress.loaded;\n\t                this._progress.total -= options._progress.total;\n\t            }\n\t            response.jqXHR = options.jqXHR = jqXHR;\n\t            response.textStatus = options.textStatus = textStatus;\n\t            response.errorThrown = options.errorThrown = errorThrown;\n\t            this._trigger('fail', null, options);\n\t        },\n\t\n\t        _onAlways: function _onAlways(jqXHRorResult, textStatus, jqXHRorError, options) {\n\t            // jqXHRorResult, textStatus and jqXHRorError are added to the\n\t            // options object via done and fail callbacks\n\t            this._trigger('always', null, options);\n\t        },\n\t\n\t        _onSend: function _onSend(e, data) {\n\t            if (!data.submit) {\n\t                this._addConvenienceMethods(e, data);\n\t            }\n\t            var that = this,\n\t                jqXHR,\n\t                aborted,\n\t                slot,\n\t                pipe,\n\t                options = that._getAJAXSettings(data),\n\t                send = function send() {\n\t                that._sending += 1;\n\t                // Set timer for bitrate progress calculation:\n\t                options._bitrateTimer = new that._BitrateTimer();\n\t                jqXHR = jqXHR || ((aborted || that._trigger('send', $.Event('send', { delegatedEvent: e }), options) === false) && that._getXHRPromise(false, options.context, aborted) || that._chunkedUpload(options) || $.ajax(options)).done(function (result, textStatus, jqXHR) {\n\t                    that._onDone(result, textStatus, jqXHR, options);\n\t                }).fail(function (jqXHR, textStatus, errorThrown) {\n\t                    that._onFail(jqXHR, textStatus, errorThrown, options);\n\t                }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\n\t                    that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options);\n\t                    that._sending -= 1;\n\t                    that._active -= 1;\n\t                    if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) {\n\t                        // Start the next queued upload,\n\t                        // that has not been aborted:\n\t                        var nextSlot = that._slots.shift();\n\t                        while (nextSlot) {\n\t                            if (that._getDeferredState(nextSlot) === 'pending') {\n\t                                nextSlot.resolve();\n\t                                break;\n\t                            }\n\t                            nextSlot = that._slots.shift();\n\t                        }\n\t                    }\n\t                    if (that._active === 0) {\n\t                        // The stop callback is triggered when all uploads have\n\t                        // been completed, equivalent to the global ajaxStop event:\n\t                        that._trigger('stop');\n\t                    }\n\t                });\n\t                return jqXHR;\n\t            };\n\t            this._beforeSend(e, options);\n\t            if (this.options.sequentialUploads || this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending) {\n\t                if (this.options.limitConcurrentUploads > 1) {\n\t                    slot = $.Deferred();\n\t                    this._slots.push(slot);\n\t                    pipe = slot.then(send);\n\t                } else {\n\t                    this._sequence = this._sequence.then(send, send);\n\t                    pipe = this._sequence;\n\t                }\n\t                // Return the piped Promise object, enhanced with an abort method,\n\t                // which is delegated to the jqXHR object of the current upload,\n\t                // and jqXHR callbacks mapped to the equivalent Promise methods:\n\t                pipe.abort = function () {\n\t                    aborted = [undefined, 'abort', 'abort'];\n\t                    if (!jqXHR) {\n\t                        if (slot) {\n\t                            slot.rejectWith(options.context, aborted);\n\t                        }\n\t                        return send();\n\t                    }\n\t                    return jqXHR.abort();\n\t                };\n\t                return this._enhancePromise(pipe);\n\t            }\n\t            return send();\n\t        },\n\t\n\t        _onAdd: function _onAdd(e, data) {\n\t            var that = this,\n\t                result = true,\n\t                options = $.extend({}, this.options, data),\n\t                files = data.files,\n\t                filesLength = files.length,\n\t                limit = options.limitMultiFileUploads,\n\t                limitSize = options.limitMultiFileUploadSize,\n\t                overhead = options.limitMultiFileUploadSizeOverhead,\n\t                batchSize = 0,\n\t                paramName = this._getParamName(options),\n\t                paramNameSet,\n\t                paramNameSlice,\n\t                fileSet,\n\t                i,\n\t                j = 0;\n\t            if (!filesLength) {\n\t                return false;\n\t            }\n\t            if (limitSize && files[0].size === undefined) {\n\t                limitSize = undefined;\n\t            }\n\t            if (!(options.singleFileUploads || limit || limitSize) || !this._isXHRUpload(options)) {\n\t                fileSet = [files];\n\t                paramNameSet = [paramName];\n\t            } else if (!(options.singleFileUploads || limitSize) && limit) {\n\t                fileSet = [];\n\t                paramNameSet = [];\n\t                for (i = 0; i < filesLength; i += limit) {\n\t                    fileSet.push(files.slice(i, i + limit));\n\t                    paramNameSlice = paramName.slice(i, i + limit);\n\t                    if (!paramNameSlice.length) {\n\t                        paramNameSlice = paramName;\n\t                    }\n\t                    paramNameSet.push(paramNameSlice);\n\t                }\n\t            } else if (!options.singleFileUploads && limitSize) {\n\t                fileSet = [];\n\t                paramNameSet = [];\n\t                for (i = 0; i < filesLength; i = i + 1) {\n\t                    batchSize += files[i].size + overhead;\n\t                    if (i + 1 === filesLength || batchSize + files[i + 1].size + overhead > limitSize || limit && i + 1 - j >= limit) {\n\t                        fileSet.push(files.slice(j, i + 1));\n\t                        paramNameSlice = paramName.slice(j, i + 1);\n\t                        if (!paramNameSlice.length) {\n\t                            paramNameSlice = paramName;\n\t                        }\n\t                        paramNameSet.push(paramNameSlice);\n\t                        j = i + 1;\n\t                        batchSize = 0;\n\t                    }\n\t                }\n\t            } else {\n\t                paramNameSet = paramName;\n\t            }\n\t            data.originalFiles = files;\n\t            $.each(fileSet || files, function (index, element) {\n\t                var newData = $.extend({}, data);\n\t                newData.files = fileSet ? element : [element];\n\t                newData.paramName = paramNameSet[index];\n\t                that._initResponseObject(newData);\n\t                that._initProgressObject(newData);\n\t                that._addConvenienceMethods(e, newData);\n\t                result = that._trigger('add', $.Event('add', { delegatedEvent: e }), newData);\n\t                return result;\n\t            });\n\t            return result;\n\t        },\n\t\n\t        _replaceFileInput: function _replaceFileInput(data) {\n\t            var input = data.fileInput,\n\t                inputClone = input.clone(true),\n\t                restoreFocus = input.is(document.activeElement);\n\t            // Add a reference for the new cloned file input to the data argument:\n\t            data.fileInputClone = inputClone;\n\t            $('<form></form>').append(inputClone)[0].reset();\n\t            // Detaching allows to insert the fileInput on another form\n\t            // without loosing the file input value:\n\t            input.after(inputClone).detach();\n\t            // If the fileInput had focus before it was detached,\n\t            // restore focus to the inputClone.\n\t            if (restoreFocus) {\n\t                inputClone.focus();\n\t            }\n\t            // Avoid memory leaks with the detached file input:\n\t            $.cleanData(input.unbind('remove'));\n\t            // Replace the original file input element in the fileInput\n\t            // elements set with the clone, which has been copied including\n\t            // event handlers:\n\t            this.options.fileInput = this.options.fileInput.map(function (i, el) {\n\t                if (el === input[0]) {\n\t                    return inputClone[0];\n\t                }\n\t                return el;\n\t            });\n\t            // If the widget has been initialized on the file input itself,\n\t            // override this.element with the file input clone:\n\t            if (input[0] === this.element[0]) {\n\t                this.element = inputClone;\n\t            }\n\t        },\n\t\n\t        _handleFileTreeEntry: function _handleFileTreeEntry(entry, path) {\n\t            var that = this,\n\t                dfd = $.Deferred(),\n\t                errorHandler = function errorHandler(e) {\n\t                if (e && !e.entry) {\n\t                    e.entry = entry;\n\t                }\n\t                // Since $.when returns immediately if one\n\t                // Deferred is rejected, we use resolve instead.\n\t                // This allows valid files and invalid items\n\t                // to be returned together in one set:\n\t                dfd.resolve([e]);\n\t            },\n\t                successHandler = function successHandler(entries) {\n\t                that._handleFileTreeEntries(entries, path + entry.name + '/').done(function (files) {\n\t                    dfd.resolve(files);\n\t                }).fail(errorHandler);\n\t            },\n\t                readEntries = function readEntries() {\n\t                dirReader.readEntries(function (results) {\n\t                    if (!results.length) {\n\t                        successHandler(entries);\n\t                    } else {\n\t                        entries = entries.concat(results);\n\t                        readEntries();\n\t                    }\n\t                }, errorHandler);\n\t            },\n\t                dirReader,\n\t                entries = [];\n\t            path = path || '';\n\t            if (entry.isFile) {\n\t                if (entry._file) {\n\t                    // Workaround for Chrome bug #149735\n\t                    entry._file.relativePath = path;\n\t                    dfd.resolve(entry._file);\n\t                } else {\n\t                    entry.file(function (file) {\n\t                        file.relativePath = path;\n\t                        dfd.resolve(file);\n\t                    }, errorHandler);\n\t                }\n\t            } else if (entry.isDirectory) {\n\t                dirReader = entry.createReader();\n\t                readEntries();\n\t            } else {\n\t                // Return an empy list for file system items\n\t                // other than files or directories:\n\t                dfd.resolve([]);\n\t            }\n\t            return dfd.promise();\n\t        },\n\t\n\t        _handleFileTreeEntries: function _handleFileTreeEntries(entries, path) {\n\t            var that = this;\n\t            return $.when.apply($, $.map(entries, function (entry) {\n\t                return that._handleFileTreeEntry(entry, path);\n\t            })).then(function () {\n\t                return Array.prototype.concat.apply([], arguments);\n\t            });\n\t        },\n\t\n\t        _getDroppedFiles: function _getDroppedFiles(dataTransfer) {\n\t            dataTransfer = dataTransfer || {};\n\t            var items = dataTransfer.items;\n\t            if (items && items.length && (items[0].webkitGetAsEntry || items[0].getAsEntry)) {\n\t                return this._handleFileTreeEntries($.map(items, function (item) {\n\t                    var entry;\n\t                    if (item.webkitGetAsEntry) {\n\t                        entry = item.webkitGetAsEntry();\n\t                        if (entry) {\n\t                            // Workaround for Chrome bug #149735:\n\t                            entry._file = item.getAsFile();\n\t                        }\n\t                        return entry;\n\t                    }\n\t                    return item.getAsEntry();\n\t                }));\n\t            }\n\t            return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();\n\t        },\n\t\n\t        _getSingleFileInputFiles: function _getSingleFileInputFiles(fileInput) {\n\t            fileInput = $(fileInput);\n\t            var entries = fileInput.prop('webkitEntries') || fileInput.prop('entries'),\n\t                files,\n\t                value;\n\t            if (entries && entries.length) {\n\t                return this._handleFileTreeEntries(entries);\n\t            }\n\t            files = $.makeArray(fileInput.prop('files'));\n\t            if (!files.length) {\n\t                value = fileInput.prop('value');\n\t                if (!value) {\n\t                    return $.Deferred().resolve([]).promise();\n\t                }\n\t                // If the files property is not available, the browser does not\n\t                // support the File API and we add a pseudo File object with\n\t                // the input value as name with path information removed:\n\t                files = [{ name: value.replace(/^.*\\\\/, '') }];\n\t            } else if (files[0].name === undefined && files[0].fileName) {\n\t                // File normalization for Safari 4 and Firefox 3:\n\t                $.each(files, function (index, file) {\n\t                    file.name = file.fileName;\n\t                    file.size = file.fileSize;\n\t                });\n\t            }\n\t            return $.Deferred().resolve(files).promise();\n\t        },\n\t\n\t        _getFileInputFiles: function _getFileInputFiles(fileInput) {\n\t            if (!(fileInput instanceof $) || fileInput.length === 1) {\n\t                return this._getSingleFileInputFiles(fileInput);\n\t            }\n\t            return $.when.apply($, $.map(fileInput, this._getSingleFileInputFiles)).then(function () {\n\t                return Array.prototype.concat.apply([], arguments);\n\t            });\n\t        },\n\t\n\t        _onChange: function _onChange(e) {\n\t            var that = this,\n\t                data = {\n\t                fileInput: $(e.target),\n\t                form: $(e.target.form)\n\t            };\n\t            this._getFileInputFiles(data.fileInput).always(function (files) {\n\t                data.files = files;\n\t                if (that.options.replaceFileInput) {\n\t                    that._replaceFileInput(data);\n\t                }\n\t                if (that._trigger('change', $.Event('change', { delegatedEvent: e }), data) !== false) {\n\t                    that._onAdd(e, data);\n\t                }\n\t            });\n\t        },\n\t\n\t        _onPaste: function _onPaste(e) {\n\t            var items = e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.items,\n\t                data = { files: [] };\n\t            if (items && items.length) {\n\t                $.each(items, function (index, item) {\n\t                    var file = item.getAsFile && item.getAsFile();\n\t                    if (file) {\n\t                        data.files.push(file);\n\t                    }\n\t                });\n\t                if (this._trigger('paste', $.Event('paste', { delegatedEvent: e }), data) !== false) {\n\t                    this._onAdd(e, data);\n\t                }\n\t            }\n\t        },\n\t\n\t        _onDrop: function _onDrop(e) {\n\t            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\n\t            var that = this,\n\t                dataTransfer = e.dataTransfer,\n\t                data = {};\n\t            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n\t                e.preventDefault();\n\t                this._getDroppedFiles(dataTransfer).always(function (files) {\n\t                    data.files = files;\n\t                    if (that._trigger('drop', $.Event('drop', { delegatedEvent: e }), data) !== false) {\n\t                        that._onAdd(e, data);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        _onDragOver: getDragHandler('dragover'),\n\t\n\t        _onDragEnter: getDragHandler('dragenter'),\n\t\n\t        _onDragLeave: getDragHandler('dragleave'),\n\t\n\t        _initEventHandlers: function _initEventHandlers() {\n\t            if (this._isXHRUpload(this.options)) {\n\t                this._on(this.options.dropZone, {\n\t                    dragover: this._onDragOver,\n\t                    drop: this._onDrop,\n\t                    // event.preventDefault() on dragenter is required for IE10+:\n\t                    dragenter: this._onDragEnter,\n\t                    // dragleave is not required, but added for completeness:\n\t                    dragleave: this._onDragLeave\n\t                });\n\t                this._on(this.options.pasteZone, {\n\t                    paste: this._onPaste\n\t                });\n\t            }\n\t            if ($.support.fileInput) {\n\t                this._on(this.options.fileInput, {\n\t                    change: this._onChange\n\t                });\n\t            }\n\t        },\n\t\n\t        _destroyEventHandlers: function _destroyEventHandlers() {\n\t            this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\n\t            this._off(this.options.pasteZone, 'paste');\n\t            this._off(this.options.fileInput, 'change');\n\t        },\n\t\n\t        _setOption: function _setOption(key, value) {\n\t            var reinit = $.inArray(key, this._specialOptions) !== -1;\n\t            if (reinit) {\n\t                this._destroyEventHandlers();\n\t            }\n\t            this._super(key, value);\n\t            if (reinit) {\n\t                this._initSpecialOptions();\n\t                this._initEventHandlers();\n\t            }\n\t        },\n\t\n\t        _initSpecialOptions: function _initSpecialOptions() {\n\t            var options = this.options;\n\t            if (options.fileInput === undefined) {\n\t                options.fileInput = this.element.is('input[type=\"file\"]') ? this.element : this.element.find('input[type=\"file\"]');\n\t            } else if (!(options.fileInput instanceof $)) {\n\t                options.fileInput = $(options.fileInput);\n\t            }\n\t            if (!(options.dropZone instanceof $)) {\n\t                options.dropZone = $(options.dropZone);\n\t            }\n\t            if (!(options.pasteZone instanceof $)) {\n\t                options.pasteZone = $(options.pasteZone);\n\t            }\n\t        },\n\t\n\t        _getRegExp: function _getRegExp(str) {\n\t            var parts = str.split('/'),\n\t                modifiers = parts.pop();\n\t            parts.shift();\n\t            return new RegExp(parts.join('/'), modifiers);\n\t        },\n\t\n\t        _isRegExpOption: function _isRegExpOption(key, value) {\n\t            return key !== 'url' && $.type(value) === 'string' && /^\\/.*\\/[igm]{0,3}$/.test(value);\n\t        },\n\t\n\t        _initDataAttributes: function _initDataAttributes() {\n\t            var that = this,\n\t                options = this.options,\n\t                data = this.element.data();\n\t            // Initialize options set via HTML5 data-attributes:\n\t            $.each(this.element[0].attributes, function (index, attr) {\n\t                var key = attr.name.toLowerCase(),\n\t                    value;\n\t                if (/^data-/.test(key)) {\n\t                    // Convert hyphen-ated key to camelCase:\n\t                    key = key.slice(5).replace(/-[a-z]/g, function (str) {\n\t                        return str.charAt(1).toUpperCase();\n\t                    });\n\t                    value = data[key];\n\t                    if (that._isRegExpOption(key, value)) {\n\t                        value = that._getRegExp(value);\n\t                    }\n\t                    options[key] = value;\n\t                }\n\t            });\n\t        },\n\t\n\t        _create: function _create() {\n\t            this._initDataAttributes();\n\t            this._initSpecialOptions();\n\t            this._slots = [];\n\t            this._sequence = this._getXHRPromise(true);\n\t            this._sending = this._active = 0;\n\t            this._initProgressObject(this);\n\t            this._initEventHandlers();\n\t        },\n\t\n\t        // This method is exposed to the widget API and allows to query\n\t        // the number of active uploads:\n\t        active: function active() {\n\t            return this._active;\n\t        },\n\t\n\t        // This method is exposed to the widget API and allows to query\n\t        // the widget upload progress.\n\t        // It returns an object with loaded, total and bitrate properties\n\t        // for the running uploads:\n\t        progress: function progress() {\n\t            return this._progress;\n\t        },\n\t\n\t        // This method is exposed to the widget API and allows adding files\n\t        // using the fileupload API. The data parameter accepts an object which\n\t        // must have a files property and can contain additional options:\n\t        // .fileupload('add', {files: filesList});\n\t        add: function add(data) {\n\t            var that = this;\n\t            if (!data || this.options.disabled) {\n\t                return;\n\t            }\n\t            if (data.fileInput && !data.files) {\n\t                this._getFileInputFiles(data.fileInput).always(function (files) {\n\t                    data.files = files;\n\t                    that._onAdd(null, data);\n\t                });\n\t            } else {\n\t                data.files = $.makeArray(data.files);\n\t                this._onAdd(null, data);\n\t            }\n\t        },\n\t\n\t        // This method is exposed to the widget API and allows sending files\n\t        // using the fileupload API. The data parameter accepts an object which\n\t        // must have a files or fileInput property and can contain additional options:\n\t        // .fileupload('send', {files: filesList});\n\t        // The method returns a Promise object for the file upload call.\n\t        send: function send(data) {\n\t            if (data && !this.options.disabled) {\n\t                if (data.fileInput && !data.files) {\n\t                    var that = this,\n\t                        dfd = $.Deferred(),\n\t                        promise = dfd.promise(),\n\t                        jqXHR,\n\t                        aborted;\n\t                    promise.abort = function () {\n\t                        aborted = true;\n\t                        if (jqXHR) {\n\t                            return jqXHR.abort();\n\t                        }\n\t                        dfd.reject(null, 'abort', 'abort');\n\t                        return promise;\n\t                    };\n\t                    this._getFileInputFiles(data.fileInput).always(function (files) {\n\t                        if (aborted) {\n\t                            return;\n\t                        }\n\t                        if (!files.length) {\n\t                            dfd.reject();\n\t                            return;\n\t                        }\n\t                        data.files = files;\n\t                        jqXHR = that._onSend(null, data);\n\t                        jqXHR.then(function (result, textStatus, jqXHR) {\n\t                            dfd.resolve(result, textStatus, jqXHR);\n\t                        }, function (jqXHR, textStatus, errorThrown) {\n\t                            dfd.reject(jqXHR, textStatus, errorThrown);\n\t                        });\n\t                    });\n\t                    return this._enhancePromise(promise);\n\t                }\n\t                data.files = $.makeArray(data.files);\n\t                if (data.files.length) {\n\t                    return this._onSend(null, data);\n\t                }\n\t            }\n\t            return this._getXHRPromise(false, data && data.context);\n\t        }\n\t\n\t    });\n\t});\n\n/***/ },\n\n/***/ 189:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*! jQuery UI - v1.11.4+CommonJS - 2015-08-28\n\t* http://jqueryui.com\n\t* Includes: widget.js\n\t* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\n\t\n\t(function (factory) {\n\t\tif (true) {\n\t\n\t\t\t// AMD. Register as an anonymous module.\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\") {\n\t\n\t\t\t// Node/CommonJS\n\t\t\tfactory(require(\"jquery\"));\n\t\t} else {\n\t\n\t\t\t// Browser globals\n\t\t\tfactory(jQuery);\n\t\t}\n\t})(function ($) {\n\t\t/*!\n\t  * jQuery UI Widget 1.11.4\n\t  * http://jqueryui.com\n\t  *\n\t  * Copyright jQuery Foundation and other contributors\n\t  * Released under the MIT license.\n\t  * http://jquery.org/license\n\t  *\n\t  * http://api.jqueryui.com/jQuery.widget/\n\t  */\n\t\n\t\tvar widget_uuid = 0,\n\t\t    widget_slice = Array.prototype.slice;\n\t\n\t\t$.cleanData = function (orig) {\n\t\t\treturn function (elems) {\n\t\t\t\tvar events, elem, i;\n\t\t\t\tfor (i = 0; (elem = elems[i]) != null; i++) {\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\t// Only trigger remove when necessary to save time\n\t\t\t\t\t\tevents = $._data(elem, \"events\");\n\t\t\t\t\t\tif (events && events.remove) {\n\t\t\t\t\t\t\t$(elem).triggerHandler(\"remove\");\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// http://bugs.jquery.com/ticket/8235\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\t\t\t\torig(elems);\n\t\t\t};\n\t\t}($.cleanData);\n\t\n\t\t$.widget = function (name, base, prototype) {\n\t\t\tvar fullName,\n\t\t\t    existingConstructor,\n\t\t\t    constructor,\n\t\t\t    basePrototype,\n\t\n\t\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\t\tproxiedPrototype = {},\n\t\t\t    namespace = name.split(\".\")[0];\n\t\n\t\t\tname = name.split(\".\")[1];\n\t\t\tfullName = namespace + \"-\" + name;\n\t\n\t\t\tif (!prototype) {\n\t\t\t\tprototype = base;\n\t\t\t\tbase = $.Widget;\n\t\t\t}\n\t\n\t\t\t// create selector for plugin\n\t\t\t$.expr[\":\"][fullName.toLowerCase()] = function (elem) {\n\t\t\t\treturn !!$.data(elem, fullName);\n\t\t\t};\n\t\n\t\t\t$[namespace] = $[namespace] || {};\n\t\t\texistingConstructor = $[namespace][name];\n\t\t\tconstructor = $[namespace][name] = function (options, element) {\n\t\t\t\t// allow instantiation without \"new\" keyword\n\t\t\t\tif (!this._createWidget) {\n\t\t\t\t\treturn new constructor(options, element);\n\t\t\t\t}\n\t\n\t\t\t\t// allow instantiation without initializing for simple inheritance\n\t\t\t\t// must use \"new\" keyword (the code above always passes args)\n\t\t\t\tif (arguments.length) {\n\t\t\t\t\tthis._createWidget(options, element);\n\t\t\t\t}\n\t\t\t};\n\t\t\t// extend with the existing constructor to carry over any static properties\n\t\t\t$.extend(constructor, existingConstructor, {\n\t\t\t\tversion: prototype.version,\n\t\t\t\t// copy the object used to create the prototype in case we need to\n\t\t\t\t// redefine the widget later\n\t\t\t\t_proto: $.extend({}, prototype),\n\t\t\t\t// track widgets that inherit from this widget in case this widget is\n\t\t\t\t// redefined after a widget inherits from it\n\t\t\t\t_childConstructors: []\n\t\t\t});\n\t\n\t\t\tbasePrototype = new base();\n\t\t\t// we need to make the options hash a property directly on the new instance\n\t\t\t// otherwise we'll modify the options hash on the prototype that we're\n\t\t\t// inheriting from\n\t\t\tbasePrototype.options = $.widget.extend({}, basePrototype.options);\n\t\t\t$.each(prototype, function (prop, value) {\n\t\t\t\tif (!$.isFunction(value)) {\n\t\t\t\t\tproxiedPrototype[prop] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tproxiedPrototype[prop] = function () {\n\t\t\t\t\tvar _super = function _super() {\n\t\t\t\t\t\treturn base.prototype[prop].apply(this, arguments);\n\t\t\t\t\t},\n\t\t\t\t\t    _superApply = function _superApply(args) {\n\t\t\t\t\t\treturn base.prototype[prop].apply(this, args);\n\t\t\t\t\t};\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\tvar __super = this._super,\n\t\t\t\t\t\t    __superApply = this._superApply,\n\t\t\t\t\t\t    returnValue;\n\t\n\t\t\t\t\t\tthis._super = _super;\n\t\t\t\t\t\tthis._superApply = _superApply;\n\t\n\t\t\t\t\t\treturnValue = value.apply(this, arguments);\n\t\n\t\t\t\t\t\tthis._super = __super;\n\t\t\t\t\t\tthis._superApply = __superApply;\n\t\n\t\t\t\t\t\treturn returnValue;\n\t\t\t\t\t};\n\t\t\t\t}();\n\t\t\t});\n\t\t\tconstructor.prototype = $.widget.extend(basePrototype, {\n\t\t\t\t// TODO: remove support for widgetEventPrefix\n\t\t\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t\t\t// don't prefix for widgets that aren't DOM-based\n\t\t\t\twidgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name\n\t\t\t}, proxiedPrototype, {\n\t\t\t\tconstructor: constructor,\n\t\t\t\tnamespace: namespace,\n\t\t\t\twidgetName: name,\n\t\t\t\twidgetFullName: fullName\n\t\t\t});\n\t\n\t\t\t// If this widget is being redefined then we need to find all widgets that\n\t\t\t// are inheriting from it and redefine all of them so that they inherit from\n\t\t\t// the new version of this widget. We're essentially trying to replace one\n\t\t\t// level in the prototype chain.\n\t\t\tif (existingConstructor) {\n\t\t\t\t$.each(existingConstructor._childConstructors, function (i, child) {\n\t\t\t\t\tvar childPrototype = child.prototype;\n\t\n\t\t\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t\t\t$.widget(childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto);\n\t\t\t\t});\n\t\t\t\t// remove the list of existing child constructors from the old constructor\n\t\t\t\t// so the old child constructors can be garbage collected\n\t\t\t\tdelete existingConstructor._childConstructors;\n\t\t\t} else {\n\t\t\t\tbase._childConstructors.push(constructor);\n\t\t\t}\n\t\n\t\t\t$.widget.bridge(name, constructor);\n\t\n\t\t\treturn constructor;\n\t\t};\n\t\n\t\t$.widget.extend = function (target) {\n\t\t\tvar input = widget_slice.call(arguments, 1),\n\t\t\t    inputIndex = 0,\n\t\t\t    inputLength = input.length,\n\t\t\t    key,\n\t\t\t    value;\n\t\t\tfor (; inputIndex < inputLength; inputIndex++) {\n\t\t\t\tfor (key in input[inputIndex]) {\n\t\t\t\t\tvalue = input[inputIndex][key];\n\t\t\t\t\tif (input[inputIndex].hasOwnProperty(key) && value !== undefined) {\n\t\t\t\t\t\t// Clone objects\n\t\t\t\t\t\tif ($.isPlainObject(value)) {\n\t\t\t\t\t\t\ttarget[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :\n\t\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\n\t\t\t\t\t\t\t$.widget.extend({}, value);\n\t\t\t\t\t\t\t// Copy everything else by reference\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\n\t\t};\n\t\n\t\t$.widget.bridge = function (name, object) {\n\t\t\tvar fullName = object.prototype.widgetFullName || name;\n\t\t\t$.fn[name] = function (options) {\n\t\t\t\tvar isMethodCall = typeof options === \"string\",\n\t\t\t\t    args = widget_slice.call(arguments, 1),\n\t\t\t\t    returnValue = this;\n\t\n\t\t\t\tif (isMethodCall) {\n\t\t\t\t\tthis.each(function () {\n\t\t\t\t\t\tvar methodValue,\n\t\t\t\t\t\t    instance = $.data(this, fullName);\n\t\t\t\t\t\tif (options === \"instance\") {\n\t\t\t\t\t\t\treturnValue = instance;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!instance) {\n\t\t\t\t\t\t\treturn $.error(\"cannot call methods on \" + name + \" prior to initialization; \" + \"attempted to call method '\" + options + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!$.isFunction(instance[options]) || options.charAt(0) === \"_\") {\n\t\t\t\t\t\t\treturn $.error(\"no such method '\" + options + \"' for \" + name + \" widget instance\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmethodValue = instance[options].apply(instance, args);\n\t\t\t\t\t\tif (methodValue !== instance && methodValue !== undefined) {\n\t\t\t\t\t\t\treturnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Allow multiple hashes to be passed on init\n\t\t\t\t\tif (args.length) {\n\t\t\t\t\t\toptions = $.widget.extend.apply(null, [options].concat(args));\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.each(function () {\n\t\t\t\t\t\tvar instance = $.data(this, fullName);\n\t\t\t\t\t\tif (instance) {\n\t\t\t\t\t\t\tinstance.option(options || {});\n\t\t\t\t\t\t\tif (instance._init) {\n\t\t\t\t\t\t\t\tinstance._init();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$.data(this, fullName, new object(options, this));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t};\n\t\n\t\t$.Widget = function () /* options, element */{};\n\t\t$.Widget._childConstructors = [];\n\t\n\t\t$.Widget.prototype = {\n\t\t\twidgetName: \"widget\",\n\t\t\twidgetEventPrefix: \"\",\n\t\t\tdefaultElement: \"<div>\",\n\t\t\toptions: {\n\t\t\t\tdisabled: false,\n\t\n\t\t\t\t// callbacks\n\t\t\t\tcreate: null\n\t\t\t},\n\t\t\t_createWidget: function _createWidget(options, element) {\n\t\t\t\telement = $(element || this.defaultElement || this)[0];\n\t\t\t\tthis.element = $(element);\n\t\t\t\tthis.uuid = widget_uuid++;\n\t\t\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\n\t\n\t\t\t\tthis.bindings = $();\n\t\t\t\tthis.hoverable = $();\n\t\t\t\tthis.focusable = $();\n\t\n\t\t\t\tif (element !== this) {\n\t\t\t\t\t$.data(element, this.widgetFullName, this);\n\t\t\t\t\tthis._on(true, this.element, {\n\t\t\t\t\t\tremove: function remove(event) {\n\t\t\t\t\t\t\tif (event.target === element) {\n\t\t\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tthis.document = $(element.style ?\n\t\t\t\t\t// element within the document\n\t\t\t\t\telement.ownerDocument :\n\t\t\t\t\t// element is window or document\n\t\t\t\t\telement.document || element);\n\t\t\t\t\tthis.window = $(this.document[0].defaultView || this.document[0].parentWindow);\n\t\t\t\t}\n\t\n\t\t\t\tthis.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);\n\t\n\t\t\t\tthis._create();\n\t\t\t\tthis._trigger(\"create\", null, this._getCreateEventData());\n\t\t\t\tthis._init();\n\t\t\t},\n\t\t\t_getCreateOptions: $.noop,\n\t\t\t_getCreateEventData: $.noop,\n\t\t\t_create: $.noop,\n\t\t\t_init: $.noop,\n\t\n\t\t\tdestroy: function destroy() {\n\t\t\t\tthis._destroy();\n\t\t\t\t// we can probably remove the unbind calls in 2.0\n\t\t\t\t// all event bindings should go through this._on()\n\t\t\t\tthis.element.unbind(this.eventNamespace).removeData(this.widgetFullName)\n\t\t\t\t// support: jquery <1.6.3\n\t\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t\t.removeData($.camelCase(this.widgetFullName));\n\t\t\t\tthis.widget().unbind(this.eventNamespace).removeAttr(\"aria-disabled\").removeClass(this.widgetFullName + \"-disabled \" + \"ui-state-disabled\");\n\t\n\t\t\t\t// clean up events and states\n\t\t\t\tthis.bindings.unbind(this.eventNamespace);\n\t\t\t\tthis.hoverable.removeClass(\"ui-state-hover\");\n\t\t\t\tthis.focusable.removeClass(\"ui-state-focus\");\n\t\t\t},\n\t\t\t_destroy: $.noop,\n\t\n\t\t\twidget: function widget() {\n\t\t\t\treturn this.element;\n\t\t\t},\n\t\n\t\t\toption: function option(key, value) {\n\t\t\t\tvar options = key,\n\t\t\t\t    parts,\n\t\t\t\t    curOption,\n\t\t\t\t    i;\n\t\n\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\t// don't return a reference to the internal hash\n\t\t\t\t\treturn $.widget.extend({}, this.options);\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof key === \"string\") {\n\t\t\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n\t\t\t\t\toptions = {};\n\t\t\t\t\tparts = key.split(\".\");\n\t\t\t\t\tkey = parts.shift();\n\t\t\t\t\tif (parts.length) {\n\t\t\t\t\t\tcurOption = options[key] = $.widget.extend({}, this.options[key]);\n\t\t\t\t\t\tfor (i = 0; i < parts.length - 1; i++) {\n\t\t\t\t\t\t\tcurOption[parts[i]] = curOption[parts[i]] || {};\n\t\t\t\t\t\t\tcurOption = curOption[parts[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkey = parts.pop();\n\t\t\t\t\t\tif (arguments.length === 1) {\n\t\t\t\t\t\t\treturn curOption[key] === undefined ? null : curOption[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurOption[key] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (arguments.length === 1) {\n\t\t\t\t\t\t\treturn this.options[key] === undefined ? null : this.options[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis._setOptions(options);\n\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_setOptions: function _setOptions(options) {\n\t\t\t\tvar key;\n\t\n\t\t\t\tfor (key in options) {\n\t\t\t\t\tthis._setOption(key, options[key]);\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t_setOption: function _setOption(key, value) {\n\t\t\t\tthis.options[key] = value;\n\t\n\t\t\t\tif (key === \"disabled\") {\n\t\t\t\t\tthis.widget().toggleClass(this.widgetFullName + \"-disabled\", !!value);\n\t\n\t\t\t\t\t// If the widget is becoming disabled, then nothing is interactive\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.hoverable.removeClass(\"ui-state-hover\");\n\t\t\t\t\t\tthis.focusable.removeClass(\"ui-state-focus\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\tenable: function enable() {\n\t\t\t\treturn this._setOptions({ disabled: false });\n\t\t\t},\n\t\t\tdisable: function disable() {\n\t\t\t\treturn this._setOptions({ disabled: true });\n\t\t\t},\n\t\n\t\t\t_on: function _on(suppressDisabledCheck, element, handlers) {\n\t\t\t\tvar delegateElement,\n\t\t\t\t    instance = this;\n\t\n\t\t\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\t\t\tif (typeof suppressDisabledCheck !== \"boolean\") {\n\t\t\t\t\thandlers = element;\n\t\t\t\t\telement = suppressDisabledCheck;\n\t\t\t\t\tsuppressDisabledCheck = false;\n\t\t\t\t}\n\t\n\t\t\t\t// no element argument, shuffle and use this.element\n\t\t\t\tif (!handlers) {\n\t\t\t\t\thandlers = element;\n\t\t\t\t\telement = this.element;\n\t\t\t\t\tdelegateElement = this.widget();\n\t\t\t\t} else {\n\t\t\t\t\telement = delegateElement = $(element);\n\t\t\t\t\tthis.bindings = this.bindings.add(element);\n\t\t\t\t}\n\t\n\t\t\t\t$.each(handlers, function (event, handler) {\n\t\t\t\t\tfunction handlerProxy() {\n\t\t\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\t\t\tif (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass(\"ui-state-disabled\"))) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// copy the guid so direct unbinding works\n\t\t\t\t\tif (typeof handler !== \"string\") {\n\t\t\t\t\t\thandlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar match = event.match(/^([\\w:-]*)\\s*(.*)$/),\n\t\t\t\t\t    eventName = match[1] + instance.eventNamespace,\n\t\t\t\t\t    selector = match[2];\n\t\t\t\t\tif (selector) {\n\t\t\t\t\t\tdelegateElement.delegate(selector, eventName, handlerProxy);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.bind(eventName, handlerProxy);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t_off: function _off(element, eventName) {\n\t\t\t\teventName = (eventName || \"\").split(\" \").join(this.eventNamespace + \" \") + this.eventNamespace;\n\t\t\t\telement.unbind(eventName).undelegate(eventName);\n\t\n\t\t\t\t// Clear the stack to avoid memory leaks (#10056)\n\t\t\t\tthis.bindings = $(this.bindings.not(element).get());\n\t\t\t\tthis.focusable = $(this.focusable.not(element).get());\n\t\t\t\tthis.hoverable = $(this.hoverable.not(element).get());\n\t\t\t},\n\t\n\t\t\t_delay: function _delay(handler, delay) {\n\t\t\t\tfunction handlerProxy() {\n\t\t\t\t\treturn (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n\t\t\t\t}\n\t\t\t\tvar instance = this;\n\t\t\t\treturn setTimeout(handlerProxy, delay || 0);\n\t\t\t},\n\t\n\t\t\t_hoverable: function _hoverable(element) {\n\t\t\t\tthis.hoverable = this.hoverable.add(element);\n\t\t\t\tthis._on(element, {\n\t\t\t\t\tmouseenter: function mouseenter(event) {\n\t\t\t\t\t\t$(event.currentTarget).addClass(\"ui-state-hover\");\n\t\t\t\t\t},\n\t\t\t\t\tmouseleave: function mouseleave(event) {\n\t\t\t\t\t\t$(event.currentTarget).removeClass(\"ui-state-hover\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t_focusable: function _focusable(element) {\n\t\t\t\tthis.focusable = this.focusable.add(element);\n\t\t\t\tthis._on(element, {\n\t\t\t\t\tfocusin: function focusin(event) {\n\t\t\t\t\t\t$(event.currentTarget).addClass(\"ui-state-focus\");\n\t\t\t\t\t},\n\t\t\t\t\tfocusout: function focusout(event) {\n\t\t\t\t\t\t$(event.currentTarget).removeClass(\"ui-state-focus\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t_trigger: function _trigger(type, event, data) {\n\t\t\t\tvar prop,\n\t\t\t\t    orig,\n\t\t\t\t    callback = this.options[type];\n\t\n\t\t\t\tdata = data || {};\n\t\t\t\tevent = $.Event(event);\n\t\t\t\tevent.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();\n\t\t\t\t// the original event may come from any element\n\t\t\t\t// so we need to reset the target on the new event\n\t\t\t\tevent.target = this.element[0];\n\t\n\t\t\t\t// copy original event properties over to the new event\n\t\t\t\torig = event.originalEvent;\n\t\t\t\tif (orig) {\n\t\t\t\t\tfor (prop in orig) {\n\t\t\t\t\t\tif (!(prop in event)) {\n\t\t\t\t\t\t\tevent[prop] = orig[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.element.trigger(event, data);\n\t\t\t\treturn !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());\n\t\t\t}\n\t\t};\n\t\n\t\t$.each({ show: \"fadeIn\", hide: \"fadeOut\" }, function (method, defaultEffect) {\n\t\t\t$.Widget.prototype[\"_\" + method] = function (element, options, callback) {\n\t\t\t\tif (typeof options === \"string\") {\n\t\t\t\t\toptions = { effect: options };\n\t\t\t\t}\n\t\t\t\tvar hasOptions,\n\t\t\t\t    effectName = !options ? method : options === true || typeof options === \"number\" ? defaultEffect : options.effect || defaultEffect;\n\t\t\t\toptions = options || {};\n\t\t\t\tif (typeof options === \"number\") {\n\t\t\t\t\toptions = { duration: options };\n\t\t\t\t}\n\t\t\t\thasOptions = !$.isEmptyObject(options);\n\t\t\t\toptions.complete = callback;\n\t\t\t\tif (options.delay) {\n\t\t\t\t\telement.delay(options.delay);\n\t\t\t\t}\n\t\t\t\tif (hasOptions && $.effects && $.effects.effect[effectName]) {\n\t\t\t\t\telement[method](options);\n\t\t\t\t} else if (effectName !== method && element[effectName]) {\n\t\t\t\t\telement[effectName](options.duration, options.easing, callback);\n\t\t\t\t} else {\n\t\t\t\t\telement.queue(function (next) {\n\t\t\t\t\t\t$(this)[method]();\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\tcallback.call(element[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\n\t\tvar widget = $.widget;\n\t});\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** 3.3.js\n **/","/*\n * jQuery File Upload Plugin\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2010, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * http://www.opensource.org/licenses/MIT\n */\n\n/* jshint nomen:false */\n/* global define, require, window, document, location, Blob, FormData */\n\n;(function (factory) {\n    'use strict';\n    //if (typeof define === 'function' && define.amd) {\n    //    // Register as an anonymous AMD module:\n    //    define([\n    //        'jquery',\n    //        'jquery.ui.widget'\n    //    ], factory);\n    //} else\n    if (typeof exports === 'object') {\n        // Node/CommonJS:\n        factory(\n            require('jquery'),\n            require('./vendor/jquery.ui.widget.js')\n        );\n    } else {\n        // Browser globals:\n        factory(window.jQuery);\n    }\n}(function ($) {\n    'use strict';\n\n    // Detect file input support, based on\n    // http://viljamis.com/blog/2012/file-upload-support-on-mobile/\n    $.support.fileInput = !(new RegExp(\n        // Handle devices which give false positives for the feature detection:\n        '(Android (1\\\\.[0156]|2\\\\.[01]))' +\n            '|(Windows Phone (OS 7|8\\\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +\n            '|(w(eb)?OSBrowser)|(webOS)' +\n            '|(Kindle/(1\\\\.0|2\\\\.[05]|3\\\\.0))'\n    ).test(window.navigator.userAgent) ||\n        // Feature detection for all other devices:\n        $('<input type=\"file\">').prop('disabled'));\n\n    // The FileReader API is not actually used, but works as feature detection,\n    // as some Safari versions (5?) support XHR file uploads via the FormData API,\n    // but not non-multipart XHR file uploads.\n    // window.XMLHttpRequestUpload is not available on IE10, so we check for\n    // window.ProgressEvent instead to detect XHR2 file upload capability:\n    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\n    $.support.xhrFormDataFileUpload = !!window.FormData;\n\n    // Detect support for Blob slicing (required for chunked uploads):\n    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||\n        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n\n    // Helper function to create drag handlers for dragover/dragenter/dragleave:\n    function getDragHandler(type) {\n        var isDragOver = type === 'dragover';\n        return function (e) {\n            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\n            var dataTransfer = e.dataTransfer;\n            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 &&\n                    this._trigger(\n                        type,\n                        $.Event(type, {delegatedEvent: e})\n                    ) !== false) {\n                e.preventDefault();\n                if (isDragOver) {\n                    dataTransfer.dropEffect = 'copy';\n                }\n            }\n        };\n    }\n\n    // The fileupload widget listens for change events on file input fields defined\n    // via fileInput setting and paste or drop events of the given dropZone.\n    // In addition to the default jQuery Widget methods, the fileupload widget\n    // exposes the \"add\" and \"send\" methods, to add or directly send files using\n    // the fileupload API.\n    // By default, files added via file input selection, paste, drag & drop or\n    // \"add\" method are uploaded immediately, but it is possible to override\n    // the \"add\" callback option to queue file uploads.\n    $.widget('blueimp.fileupload', {\n\n        options: {\n            // The drop target element(s), by the default the complete document.\n            // Set to null to disable drag & drop support:\n            dropZone: $(document),\n            // The paste target element(s), by the default undefined.\n            // Set to a DOM node or jQuery object to enable file pasting:\n            pasteZone: undefined,\n            // The file input field(s), that are listened to for change events.\n            // If undefined, it is set to the file input fields inside\n            // of the widget element on plugin initialization.\n            // Set to null to disable the change listener.\n            fileInput: undefined,\n            // By default, the file input field is replaced with a clone after\n            // each input field change event. This is required for iframe transport\n            // queues and allows change events to be fired for the same file\n            // selection, but can be disabled by setting the following option to false:\n            replaceFileInput: true,\n            // The parameter name for the file form data (the request argument name).\n            // If undefined or empty, the name property of the file input field is\n            // used, or \"files[]\" if the file input name property is also empty,\n            // can be a string or an array of strings:\n            paramName: undefined,\n            // By default, each file of a selection is uploaded using an individual\n            // request for XHR type uploads. Set to false to upload file\n            // selections in one request each:\n            singleFileUploads: true,\n            // To limit the number of files uploaded with one XHR request,\n            // set the following option to an integer greater than 0:\n            limitMultiFileUploads: undefined,\n            // The following option limits the number of files uploaded with one\n            // XHR request to keep the request size under or equal to the defined\n            // limit in bytes:\n            limitMultiFileUploadSize: undefined,\n            // Multipart file uploads add a number of bytes to each uploaded file,\n            // therefore the following option adds an overhead for each file used\n            // in the limitMultiFileUploadSize configuration:\n            limitMultiFileUploadSizeOverhead: 512,\n            // Set the following option to true to issue all file upload requests\n            // in a sequential order:\n            sequentialUploads: false,\n            // To limit the number of concurrent uploads,\n            // set the following option to an integer greater than 0:\n            limitConcurrentUploads: undefined,\n            // Set the following option to true to force iframe transport uploads:\n            forceIframeTransport: false,\n            // Set the following option to the location of a redirect url on the\n            // origin server, for cross-domain iframe transport uploads:\n            redirect: undefined,\n            // The parameter name for the redirect url, sent as part of the form\n            // data and set to 'redirect' if this option is empty:\n            redirectParamName: undefined,\n            // Set the following option to the location of a postMessage window,\n            // to enable postMessage transport uploads:\n            postMessage: undefined,\n            // By default, XHR file uploads are sent as multipart/form-data.\n            // The iframe transport is always using multipart/form-data.\n            // Set to false to enable non-multipart XHR uploads:\n            multipart: true,\n            // To upload large files in smaller chunks, set the following option\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\n            // or the browser does not support the required Blob API, files will\n            // be uploaded as a whole.\n            maxChunkSize: undefined,\n            // When a non-multipart upload or a chunked multipart upload has been\n            // aborted, this option can be used to resume the upload by setting\n            // it to the size of the already uploaded bytes. This option is most\n            // useful when modifying the options object inside of the \"add\" or\n            // \"send\" callbacks, as the options are cloned for each file upload.\n            uploadedBytes: undefined,\n            // By default, failed (abort or error) file uploads are removed from the\n            // global progress calculation. Set the following option to false to\n            // prevent recalculating the global progress data:\n            recalculateProgress: true,\n            // Interval in milliseconds to calculate and trigger progress events:\n            progressInterval: 100,\n            // Interval in milliseconds to calculate progress bitrate:\n            bitrateInterval: 500,\n            // By default, uploads are started automatically when adding files:\n            autoUpload: true,\n\n            // Error and info messages:\n            messages: {\n                uploadedBytes: 'Uploaded bytes exceed file size'\n            },\n\n            // Translation function, gets the message key to be translated\n            // and an object with context specific data as arguments:\n            i18n: function (message, context) {\n                message = this.messages[message] || message.toString();\n                if (context) {\n                    $.each(context, function (key, value) {\n                        message = message.replace('{' + key + '}', value);\n                    });\n                }\n                return message;\n            },\n\n            // Additional form data to be sent along with the file uploads can be set\n            // using this option, which accepts an array of objects with name and\n            // value properties, a function returning such an array, a FormData\n            // object (for XHR file uploads), or a simple object.\n            // The form of the first fileInput is given as parameter to the function:\n            formData: function (form) {\n                return form.serializeArray();\n            },\n\n            // The add callback is invoked as soon as files are added to the fileupload\n            // widget (via file input selection, drag & drop, paste or add API call).\n            // If the singleFileUploads option is enabled, this callback will be\n            // called once for each file in the selection for XHR file uploads, else\n            // once for each file selection.\n            //\n            // The upload starts when the submit method is invoked on the data parameter.\n            // The data object contains a files property holding the added files\n            // and allows you to override plugin options as well as define ajax settings.\n            //\n            // Listeners for this callback can also be bound the following way:\n            // .bind('fileuploadadd', func);\n            //\n            // data.submit() returns a Promise object and allows to attach additional\n            // handlers using jQuery's Deferred callbacks:\n            // data.submit().done(func).fail(func).always(func);\n            add: function (e, data) {\n                if (e.isDefaultPrevented()) {\n                    return false;\n                }\n                if (data.autoUpload || (data.autoUpload !== false &&\n                        $(this).fileupload('option', 'autoUpload'))) {\n                    data.process().done(function () {\n                        data.submit();\n                    });\n                }\n            },\n\n            // Other callbacks:\n\n            // Callback for the submit event of each file upload:\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\n\n            // Callback for the start of each file upload request:\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\n\n            // Callback for successful uploads:\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\n\n            // Callback for failed (abort or error) uploads:\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\n\n            // Callback for completed (success, abort or error) requests:\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\n\n            // Callback for upload progress events:\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\n\n            // Callback for global upload progress events:\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\n\n            // Callback for uploads start, equivalent to the global ajaxStart event:\n            // start: function (e) {}, // .bind('fileuploadstart', func);\n\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\n\n            // Callback for change events of the fileInput(s):\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\n\n            // Callback for paste events to the pasteZone(s):\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\n\n            // Callback for drop events of the dropZone(s):\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\n\n            // Callback for dragover events of the dropZone(s):\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\n\n            // Callback for the start of each chunk upload request:\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\n\n            // Callback for successful chunk uploads:\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\n\n            // Callback for failed (abort or error) chunk uploads:\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\n\n            // Callback for completed (success, abort or error) chunk upload requests:\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\n\n            // The plugin options are used as settings object for the ajax calls.\n            // The following are jQuery ajax settings required for the file uploads:\n            processData: false,\n            contentType: false,\n            cache: false,\n            timeout: 0\n        },\n\n        // A list of options that require reinitializing event listeners and/or\n        // special initialization code:\n        _specialOptions: [\n            'fileInput',\n            'dropZone',\n            'pasteZone',\n            'multipart',\n            'forceIframeTransport'\n        ],\n\n        _blobSlice: $.support.blobSlice && function () {\n            var slice = this.slice || this.webkitSlice || this.mozSlice;\n            return slice.apply(this, arguments);\n        },\n\n        _BitrateTimer: function () {\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\n            this.loaded = 0;\n            this.bitrate = 0;\n            this.getBitrate = function (now, loaded, interval) {\n                var timeDiff = now - this.timestamp;\n                if (!this.bitrate || !interval || timeDiff > interval) {\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\n                    this.loaded = loaded;\n                    this.timestamp = now;\n                }\n                return this.bitrate;\n            };\n        },\n\n        _isXHRUpload: function (options) {\n            return !options.forceIframeTransport &&\n                ((!options.multipart && $.support.xhrFileUpload) ||\n                $.support.xhrFormDataFileUpload);\n        },\n\n        _getFormData: function (options) {\n            var formData;\n            if ($.type(options.formData) === 'function') {\n                return options.formData(options.form);\n            }\n            if ($.isArray(options.formData)) {\n                return options.formData;\n            }\n            if ($.type(options.formData) === 'object') {\n                formData = [];\n                $.each(options.formData, function (name, value) {\n                    formData.push({name: name, value: value});\n                });\n                return formData;\n            }\n            return [];\n        },\n\n        _getTotal: function (files) {\n            var total = 0;\n            $.each(files, function (index, file) {\n                total += file.size || 1;\n            });\n            return total;\n        },\n\n        _initProgressObject: function (obj) {\n            var progress = {\n                loaded: 0,\n                total: 0,\n                bitrate: 0\n            };\n            if (obj._progress) {\n                $.extend(obj._progress, progress);\n            } else {\n                obj._progress = progress;\n            }\n        },\n\n        _initResponseObject: function (obj) {\n            var prop;\n            if (obj._response) {\n                for (prop in obj._response) {\n                    if (obj._response.hasOwnProperty(prop)) {\n                        delete obj._response[prop];\n                    }\n                }\n            } else {\n                obj._response = {};\n            }\n        },\n\n        _onProgress: function (e, data) {\n            if (e.lengthComputable) {\n                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),\n                    loaded;\n                if (data._time && data.progressInterval &&\n                        (now - data._time < data.progressInterval) &&\n                        e.loaded !== e.total) {\n                    return;\n                }\n                data._time = now;\n                loaded = Math.floor(\n                    e.loaded / e.total * (data.chunkSize || data._progress.total)\n                ) + (data.uploadedBytes || 0);\n                // Add the difference from the previously loaded state\n                // to the global loaded counter:\n                this._progress.loaded += (loaded - data._progress.loaded);\n                this._progress.bitrate = this._bitrateTimer.getBitrate(\n                    now,\n                    this._progress.loaded,\n                    data.bitrateInterval\n                );\n                data._progress.loaded = data.loaded = loaded;\n                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\n                    now,\n                    loaded,\n                    data.bitrateInterval\n                );\n                // Trigger a custom progress event with a total data property set\n                // to the file size(s) of the current upload and a loaded data\n                // property calculated accordingly:\n                this._trigger(\n                    'progress',\n                    $.Event('progress', {delegatedEvent: e}),\n                    data\n                );\n                // Trigger a global progress event for all current file uploads,\n                // including ajax calls queued for sequential file uploads:\n                this._trigger(\n                    'progressall',\n                    $.Event('progressall', {delegatedEvent: e}),\n                    this._progress\n                );\n            }\n        },\n\n        _initProgressListener: function (options) {\n            var that = this,\n                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\n            // Accesss to the native XHR object is required to add event listeners\n            // for the upload progress event:\n            if (xhr.upload) {\n                $(xhr.upload).bind('progress', function (e) {\n                    var oe = e.originalEvent;\n                    // Make sure the progress event properties get copied over:\n                    e.lengthComputable = oe.lengthComputable;\n                    e.loaded = oe.loaded;\n                    e.total = oe.total;\n                    that._onProgress(e, options);\n                });\n                options.xhr = function () {\n                    return xhr;\n                };\n            }\n        },\n\n        _isInstanceOf: function (type, obj) {\n            // Cross-frame instanceof check\n            return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n        },\n\n        _initXHRData: function (options) {\n            var that = this,\n                formData,\n                file = options.files[0],\n                // Ignore non-multipart setting if not supported:\n                multipart = options.multipart || !$.support.xhrFileUpload,\n                paramName = $.type(options.paramName) === 'array' ?\n                    options.paramName[0] : options.paramName;\n            options.headers = $.extend({}, options.headers);\n            if (options.contentRange) {\n                options.headers['Content-Range'] = options.contentRange;\n            }\n            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\n                options.headers['Content-Disposition'] = 'attachment; filename=\"' +\n                    encodeURI(file.name) + '\"';\n            }\n            if (!multipart) {\n                options.contentType = file.type || 'application/octet-stream';\n                options.data = options.blob || file;\n            } else if ($.support.xhrFormDataFileUpload) {\n                if (options.postMessage) {\n                    // window.postMessage does not allow sending FormData\n                    // objects, so we just add the File/Blob objects to\n                    // the formData array and let the postMessage window\n                    // create the FormData object out of this array:\n                    formData = this._getFormData(options);\n                    if (options.blob) {\n                        formData.push({\n                            name: paramName,\n                            value: options.blob\n                        });\n                    } else {\n                        $.each(options.files, function (index, file) {\n                            formData.push({\n                                name: ($.type(options.paramName) === 'array' &&\n                                    options.paramName[index]) || paramName,\n                                value: file\n                            });\n                        });\n                    }\n                } else {\n                    if (that._isInstanceOf('FormData', options.formData)) {\n                        formData = options.formData;\n                    } else {\n                        formData = new FormData();\n                        $.each(this._getFormData(options), function (index, field) {\n                            formData.append(field.name, field.value);\n                        });\n                    }\n                    if (options.blob) {\n                        formData.append(paramName, options.blob, file.name);\n                    } else {\n                        $.each(options.files, function (index, file) {\n                            // This check allows the tests to run with\n                            // dummy objects:\n                            if (that._isInstanceOf('File', file) ||\n                                    that._isInstanceOf('Blob', file)) {\n                                formData.append(\n                                    ($.type(options.paramName) === 'array' &&\n                                        options.paramName[index]) || paramName,\n                                    file,\n                                    file.uploadName || file.name\n                                );\n                            }\n                        });\n                    }\n                }\n                options.data = formData;\n            }\n            // Blob reference is not needed anymore, free memory:\n            options.blob = null;\n        },\n\n        _initIframeSettings: function (options) {\n            var targetHost = $('<a></a>').prop('href', options.url).prop('host');\n            // Setting the dataType to iframe enables the iframe transport:\n            options.dataType = 'iframe ' + (options.dataType || '');\n            // The iframe transport accepts a serialized array as form data:\n            options.formData = this._getFormData(options);\n            // Add redirect url to form data on cross-domain uploads:\n            if (options.redirect && targetHost && targetHost !== location.host) {\n                options.formData.push({\n                    name: options.redirectParamName || 'redirect',\n                    value: options.redirect\n                });\n            }\n        },\n\n        _initDataSettings: function (options) {\n            if (this._isXHRUpload(options)) {\n                if (!this._chunkedUpload(options, true)) {\n                    if (!options.data) {\n                        this._initXHRData(options);\n                    }\n                    this._initProgressListener(options);\n                }\n                if (options.postMessage) {\n                    // Setting the dataType to postmessage enables the\n                    // postMessage transport:\n                    options.dataType = 'postmessage ' + (options.dataType || '');\n                }\n            } else {\n                this._initIframeSettings(options);\n            }\n        },\n\n        _getParamName: function (options) {\n            var fileInput = $(options.fileInput),\n                paramName = options.paramName;\n            if (!paramName) {\n                paramName = [];\n                fileInput.each(function () {\n                    var input = $(this),\n                        name = input.prop('name') || 'files[]',\n                        i = (input.prop('files') || [1]).length;\n                    while (i) {\n                        paramName.push(name);\n                        i -= 1;\n                    }\n                });\n                if (!paramName.length) {\n                    paramName = [fileInput.prop('name') || 'files[]'];\n                }\n            } else if (!$.isArray(paramName)) {\n                paramName = [paramName];\n            }\n            return paramName;\n        },\n\n        _initFormSettings: function (options) {\n            // Retrieve missing options from the input field and the\n            // associated form, if available:\n            if (!options.form || !options.form.length) {\n                options.form = $(options.fileInput.prop('form'));\n                // If the given file input doesn't have an associated form,\n                // use the default widget file input's form:\n                if (!options.form.length) {\n                    options.form = $(this.options.fileInput.prop('form'));\n                }\n            }\n            options.paramName = this._getParamName(options);\n            if (!options.url) {\n                options.url = options.form.prop('action') || location.href;\n            }\n            // The HTTP request method must be \"POST\" or \"PUT\":\n            options.type = (options.type ||\n                ($.type(options.form.prop('method')) === 'string' &&\n                    options.form.prop('method')) || ''\n                ).toUpperCase();\n            if (options.type !== 'POST' && options.type !== 'PUT' &&\n                    options.type !== 'PATCH') {\n                options.type = 'POST';\n            }\n            if (!options.formAcceptCharset) {\n                options.formAcceptCharset = options.form.attr('accept-charset');\n            }\n        },\n\n        _getAJAXSettings: function (data) {\n            var options = $.extend({}, this.options, data);\n            this._initFormSettings(options);\n            this._initDataSettings(options);\n            return options;\n        },\n\n        // jQuery 1.6 doesn't provide .state(),\n        // while jQuery 1.8+ removed .isRejected() and .isResolved():\n        _getDeferredState: function (deferred) {\n            if (deferred.state) {\n                return deferred.state();\n            }\n            if (deferred.isResolved()) {\n                return 'resolved';\n            }\n            if (deferred.isRejected()) {\n                return 'rejected';\n            }\n            return 'pending';\n        },\n\n        // Maps jqXHR callbacks to the equivalent\n        // methods of the given Promise object:\n        _enhancePromise: function (promise) {\n            promise.success = promise.done;\n            promise.error = promise.fail;\n            promise.complete = promise.always;\n            return promise;\n        },\n\n        // Creates and returns a Promise object enhanced with\n        // the jqXHR methods abort, success, error and complete:\n        _getXHRPromise: function (resolveOrReject, context, args) {\n            var dfd = $.Deferred(),\n                promise = dfd.promise();\n            context = context || this.options.context || promise;\n            if (resolveOrReject === true) {\n                dfd.resolveWith(context, args);\n            } else if (resolveOrReject === false) {\n                dfd.rejectWith(context, args);\n            }\n            promise.abort = dfd.promise;\n            return this._enhancePromise(promise);\n        },\n\n        // Adds convenience methods to the data callback argument:\n        _addConvenienceMethods: function (e, data) {\n            var that = this,\n                getPromise = function (args) {\n                    return $.Deferred().resolveWith(that, args).promise();\n                };\n            data.process = function (resolveFunc, rejectFunc) {\n                if (resolveFunc || rejectFunc) {\n                    data._processQueue = this._processQueue =\n                        (this._processQueue || getPromise([this])).then(\n                            function () {\n                                if (data.errorThrown) {\n                                    return $.Deferred()\n                                        .rejectWith(that, [data]).promise();\n                                }\n                                return getPromise(arguments);\n                            }\n                        ).then(resolveFunc, rejectFunc);\n                }\n                return this._processQueue || getPromise([this]);\n            };\n            data.submit = function () {\n                if (this.state() !== 'pending') {\n                    data.jqXHR = this.jqXHR =\n                        (that._trigger(\n                            'submit',\n                            $.Event('submit', {delegatedEvent: e}),\n                            this\n                        ) !== false) && that._onSend(e, this);\n                }\n                return this.jqXHR || that._getXHRPromise();\n            };\n            data.abort = function () {\n                if (this.jqXHR) {\n                    return this.jqXHR.abort();\n                }\n                this.errorThrown = 'abort';\n                that._trigger('fail', null, this);\n                return that._getXHRPromise(false);\n            };\n            data.state = function () {\n                if (this.jqXHR) {\n                    return that._getDeferredState(this.jqXHR);\n                }\n                if (this._processQueue) {\n                    return that._getDeferredState(this._processQueue);\n                }\n            };\n            data.processing = function () {\n                return !this.jqXHR && this._processQueue && that\n                    ._getDeferredState(this._processQueue) === 'pending';\n            };\n            data.progress = function () {\n                return this._progress;\n            };\n            data.response = function () {\n                return this._response;\n            };\n        },\n\n        // Parses the Range header from the server response\n        // and returns the uploaded bytes:\n        _getUploadedBytes: function (jqXHR) {\n            var range = jqXHR.getResponseHeader('Range'),\n                parts = range && range.split('-'),\n                upperBytesPos = parts && parts.length > 1 &&\n                    parseInt(parts[1], 10);\n            return upperBytesPos && upperBytesPos + 1;\n        },\n\n        // Uploads a file in multiple, sequential requests\n        // by splitting the file up in multiple blob chunks.\n        // If the second parameter is true, only tests if the file\n        // should be uploaded in chunks, but does not invoke any\n        // upload requests:\n        _chunkedUpload: function (options, testOnly) {\n            options.uploadedBytes = options.uploadedBytes || 0;\n            var that = this,\n                file = options.files[0],\n                fs = file.size,\n                ub = options.uploadedBytes,\n                mcs = options.maxChunkSize || fs,\n                slice = this._blobSlice,\n                dfd = $.Deferred(),\n                promise = dfd.promise(),\n                jqXHR,\n                upload;\n            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||\n                    options.data) {\n                return false;\n            }\n            if (testOnly) {\n                return true;\n            }\n            if (ub >= fs) {\n                file.error = options.i18n('uploadedBytes');\n                return this._getXHRPromise(\n                    false,\n                    options.context,\n                    [null, 'error', file.error]\n                );\n            }\n            // The chunk upload method:\n            upload = function () {\n                // Clone the options object for each chunk upload:\n                var o = $.extend({}, options),\n                    currentLoaded = o._progress.loaded;\n                o.blob = slice.call(\n                    file,\n                    ub,\n                    ub + mcs,\n                    file.type\n                );\n                // Store the current chunk size, as the blob itself\n                // will be dereferenced after data processing:\n                o.chunkSize = o.blob.size;\n                // Expose the chunk bytes position range:\n                o.contentRange = 'bytes ' + ub + '-' +\n                    (ub + o.chunkSize - 1) + '/' + fs;\n                // Process the upload data (the blob and potential form data):\n                that._initXHRData(o);\n                // Add progress listeners for this chunk upload:\n                that._initProgressListener(o);\n                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||\n                        that._getXHRPromise(false, o.context))\n                    .done(function (result, textStatus, jqXHR) {\n                        ub = that._getUploadedBytes(jqXHR) ||\n                            (ub + o.chunkSize);\n                        // Create a progress event if no final progress event\n                        // with loaded equaling total has been triggered\n                        // for this chunk:\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\n                            that._onProgress($.Event('progress', {\n                                lengthComputable: true,\n                                loaded: ub - o.uploadedBytes,\n                                total: ub - o.uploadedBytes\n                            }), o);\n                        }\n                        options.uploadedBytes = o.uploadedBytes = ub;\n                        o.result = result;\n                        o.textStatus = textStatus;\n                        o.jqXHR = jqXHR;\n                        that._trigger('chunkdone', null, o);\n                        that._trigger('chunkalways', null, o);\n                        if (ub < fs) {\n                            // File upload not yet complete,\n                            // continue with the next chunk:\n                            upload();\n                        } else {\n                            dfd.resolveWith(\n                                o.context,\n                                [result, textStatus, jqXHR]\n                            );\n                        }\n                    })\n                    .fail(function (jqXHR, textStatus, errorThrown) {\n                        o.jqXHR = jqXHR;\n                        o.textStatus = textStatus;\n                        o.errorThrown = errorThrown;\n                        that._trigger('chunkfail', null, o);\n                        that._trigger('chunkalways', null, o);\n                        dfd.rejectWith(\n                            o.context,\n                            [jqXHR, textStatus, errorThrown]\n                        );\n                    });\n            };\n            this._enhancePromise(promise);\n            promise.abort = function () {\n                return jqXHR.abort();\n            };\n            upload();\n            return promise;\n        },\n\n        _beforeSend: function (e, data) {\n            if (this._active === 0) {\n                // the start callback is triggered when an upload starts\n                // and no other uploads are currently running,\n                // equivalent to the global ajaxStart event:\n                this._trigger('start');\n                // Set timer for global bitrate progress calculation:\n                this._bitrateTimer = new this._BitrateTimer();\n                // Reset the global progress values:\n                this._progress.loaded = this._progress.total = 0;\n                this._progress.bitrate = 0;\n            }\n            // Make sure the container objects for the .response() and\n            // .progress() methods on the data object are available\n            // and reset to their initial state:\n            this._initResponseObject(data);\n            this._initProgressObject(data);\n            data._progress.loaded = data.loaded = data.uploadedBytes || 0;\n            data._progress.total = data.total = this._getTotal(data.files) || 1;\n            data._progress.bitrate = data.bitrate = 0;\n            this._active += 1;\n            // Initialize the global progress values:\n            this._progress.loaded += data.loaded;\n            this._progress.total += data.total;\n        },\n\n        _onDone: function (result, textStatus, jqXHR, options) {\n            var total = options._progress.total,\n                response = options._response;\n            if (options._progress.loaded < total) {\n                // Create a progress event if no final progress event\n                // with loaded equaling total has been triggered:\n                this._onProgress($.Event('progress', {\n                    lengthComputable: true,\n                    loaded: total,\n                    total: total\n                }), options);\n            }\n            response.result = options.result = result;\n            response.textStatus = options.textStatus = textStatus;\n            response.jqXHR = options.jqXHR = jqXHR;\n            this._trigger('done', null, options);\n        },\n\n        _onFail: function (jqXHR, textStatus, errorThrown, options) {\n            var response = options._response;\n            if (options.recalculateProgress) {\n                // Remove the failed (error or abort) file upload from\n                // the global progress calculation:\n                this._progress.loaded -= options._progress.loaded;\n                this._progress.total -= options._progress.total;\n            }\n            response.jqXHR = options.jqXHR = jqXHR;\n            response.textStatus = options.textStatus = textStatus;\n            response.errorThrown = options.errorThrown = errorThrown;\n            this._trigger('fail', null, options);\n        },\n\n        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\n            // jqXHRorResult, textStatus and jqXHRorError are added to the\n            // options object via done and fail callbacks\n            this._trigger('always', null, options);\n        },\n\n        _onSend: function (e, data) {\n            if (!data.submit) {\n                this._addConvenienceMethods(e, data);\n            }\n            var that = this,\n                jqXHR,\n                aborted,\n                slot,\n                pipe,\n                options = that._getAJAXSettings(data),\n                send = function () {\n                    that._sending += 1;\n                    // Set timer for bitrate progress calculation:\n                    options._bitrateTimer = new that._BitrateTimer();\n                    jqXHR = jqXHR || (\n                        ((aborted || that._trigger(\n                            'send',\n                            $.Event('send', {delegatedEvent: e}),\n                            options\n                        ) === false) &&\n                        that._getXHRPromise(false, options.context, aborted)) ||\n                        that._chunkedUpload(options) || $.ajax(options)\n                    ).done(function (result, textStatus, jqXHR) {\n                        that._onDone(result, textStatus, jqXHR, options);\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\n                        that._onFail(jqXHR, textStatus, errorThrown, options);\n                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\n                        that._onAlways(\n                            jqXHRorResult,\n                            textStatus,\n                            jqXHRorError,\n                            options\n                        );\n                        that._sending -= 1;\n                        that._active -= 1;\n                        if (options.limitConcurrentUploads &&\n                                options.limitConcurrentUploads > that._sending) {\n                            // Start the next queued upload,\n                            // that has not been aborted:\n                            var nextSlot = that._slots.shift();\n                            while (nextSlot) {\n                                if (that._getDeferredState(nextSlot) === 'pending') {\n                                    nextSlot.resolve();\n                                    break;\n                                }\n                                nextSlot = that._slots.shift();\n                            }\n                        }\n                        if (that._active === 0) {\n                            // The stop callback is triggered when all uploads have\n                            // been completed, equivalent to the global ajaxStop event:\n                            that._trigger('stop');\n                        }\n                    });\n                    return jqXHR;\n                };\n            this._beforeSend(e, options);\n            if (this.options.sequentialUploads ||\n                    (this.options.limitConcurrentUploads &&\n                    this.options.limitConcurrentUploads <= this._sending)) {\n                if (this.options.limitConcurrentUploads > 1) {\n                    slot = $.Deferred();\n                    this._slots.push(slot);\n                    pipe = slot.then(send);\n                } else {\n                    this._sequence = this._sequence.then(send, send);\n                    pipe = this._sequence;\n                }\n                // Return the piped Promise object, enhanced with an abort method,\n                // which is delegated to the jqXHR object of the current upload,\n                // and jqXHR callbacks mapped to the equivalent Promise methods:\n                pipe.abort = function () {\n                    aborted = [undefined, 'abort', 'abort'];\n                    if (!jqXHR) {\n                        if (slot) {\n                            slot.rejectWith(options.context, aborted);\n                        }\n                        return send();\n                    }\n                    return jqXHR.abort();\n                };\n                return this._enhancePromise(pipe);\n            }\n            return send();\n        },\n\n        _onAdd: function (e, data) {\n            var that = this,\n                result = true,\n                options = $.extend({}, this.options, data),\n                files = data.files,\n                filesLength = files.length,\n                limit = options.limitMultiFileUploads,\n                limitSize = options.limitMultiFileUploadSize,\n                overhead = options.limitMultiFileUploadSizeOverhead,\n                batchSize = 0,\n                paramName = this._getParamName(options),\n                paramNameSet,\n                paramNameSlice,\n                fileSet,\n                i,\n                j = 0;\n            if (!filesLength) {\n                return false;\n            }\n            if (limitSize && files[0].size === undefined) {\n                limitSize = undefined;\n            }\n            if (!(options.singleFileUploads || limit || limitSize) ||\n                    !this._isXHRUpload(options)) {\n                fileSet = [files];\n                paramNameSet = [paramName];\n            } else if (!(options.singleFileUploads || limitSize) && limit) {\n                fileSet = [];\n                paramNameSet = [];\n                for (i = 0; i < filesLength; i += limit) {\n                    fileSet.push(files.slice(i, i + limit));\n                    paramNameSlice = paramName.slice(i, i + limit);\n                    if (!paramNameSlice.length) {\n                        paramNameSlice = paramName;\n                    }\n                    paramNameSet.push(paramNameSlice);\n                }\n            } else if (!options.singleFileUploads && limitSize) {\n                fileSet = [];\n                paramNameSet = [];\n                for (i = 0; i < filesLength; i = i + 1) {\n                    batchSize += files[i].size + overhead;\n                    if (i + 1 === filesLength ||\n                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||\n                            (limit && i + 1 - j >= limit)) {\n                        fileSet.push(files.slice(j, i + 1));\n                        paramNameSlice = paramName.slice(j, i + 1);\n                        if (!paramNameSlice.length) {\n                            paramNameSlice = paramName;\n                        }\n                        paramNameSet.push(paramNameSlice);\n                        j = i + 1;\n                        batchSize = 0;\n                    }\n                }\n            } else {\n                paramNameSet = paramName;\n            }\n            data.originalFiles = files;\n            $.each(fileSet || files, function (index, element) {\n                var newData = $.extend({}, data);\n                newData.files = fileSet ? element : [element];\n                newData.paramName = paramNameSet[index];\n                that._initResponseObject(newData);\n                that._initProgressObject(newData);\n                that._addConvenienceMethods(e, newData);\n                result = that._trigger(\n                    'add',\n                    $.Event('add', {delegatedEvent: e}),\n                    newData\n                );\n                return result;\n            });\n            return result;\n        },\n\n        _replaceFileInput: function (data) {\n            var input = data.fileInput,\n                inputClone = input.clone(true),\n                restoreFocus = input.is(document.activeElement);\n            // Add a reference for the new cloned file input to the data argument:\n            data.fileInputClone = inputClone;\n            $('<form></form>').append(inputClone)[0].reset();\n            // Detaching allows to insert the fileInput on another form\n            // without loosing the file input value:\n            input.after(inputClone).detach();\n            // If the fileInput had focus before it was detached,\n            // restore focus to the inputClone.\n            if (restoreFocus) {\n                inputClone.focus();\n            }\n            // Avoid memory leaks with the detached file input:\n            $.cleanData(input.unbind('remove'));\n            // Replace the original file input element in the fileInput\n            // elements set with the clone, which has been copied including\n            // event handlers:\n            this.options.fileInput = this.options.fileInput.map(function (i, el) {\n                if (el === input[0]) {\n                    return inputClone[0];\n                }\n                return el;\n            });\n            // If the widget has been initialized on the file input itself,\n            // override this.element with the file input clone:\n            if (input[0] === this.element[0]) {\n                this.element = inputClone;\n            }\n        },\n\n        _handleFileTreeEntry: function (entry, path) {\n            var that = this,\n                dfd = $.Deferred(),\n                errorHandler = function (e) {\n                    if (e && !e.entry) {\n                        e.entry = entry;\n                    }\n                    // Since $.when returns immediately if one\n                    // Deferred is rejected, we use resolve instead.\n                    // This allows valid files and invalid items\n                    // to be returned together in one set:\n                    dfd.resolve([e]);\n                },\n                successHandler = function (entries) {\n                    that._handleFileTreeEntries(\n                        entries,\n                        path + entry.name + '/'\n                    ).done(function (files) {\n                        dfd.resolve(files);\n                    }).fail(errorHandler);\n                },\n                readEntries = function () {\n                    dirReader.readEntries(function (results) {\n                        if (!results.length) {\n                            successHandler(entries);\n                        } else {\n                            entries = entries.concat(results);\n                            readEntries();\n                        }\n                    }, errorHandler);\n                },\n                dirReader, entries = [];\n            path = path || '';\n            if (entry.isFile) {\n                if (entry._file) {\n                    // Workaround for Chrome bug #149735\n                    entry._file.relativePath = path;\n                    dfd.resolve(entry._file);\n                } else {\n                    entry.file(function (file) {\n                        file.relativePath = path;\n                        dfd.resolve(file);\n                    }, errorHandler);\n                }\n            } else if (entry.isDirectory) {\n                dirReader = entry.createReader();\n                readEntries();\n            } else {\n                // Return an empy list for file system items\n                // other than files or directories:\n                dfd.resolve([]);\n            }\n            return dfd.promise();\n        },\n\n        _handleFileTreeEntries: function (entries, path) {\n            var that = this;\n            return $.when.apply(\n                $,\n                $.map(entries, function (entry) {\n                    return that._handleFileTreeEntry(entry, path);\n                })\n            ).then(function () {\n                return Array.prototype.concat.apply(\n                    [],\n                    arguments\n                );\n            });\n        },\n\n        _getDroppedFiles: function (dataTransfer) {\n            dataTransfer = dataTransfer || {};\n            var items = dataTransfer.items;\n            if (items && items.length && (items[0].webkitGetAsEntry ||\n                    items[0].getAsEntry)) {\n                return this._handleFileTreeEntries(\n                    $.map(items, function (item) {\n                        var entry;\n                        if (item.webkitGetAsEntry) {\n                            entry = item.webkitGetAsEntry();\n                            if (entry) {\n                                // Workaround for Chrome bug #149735:\n                                entry._file = item.getAsFile();\n                            }\n                            return entry;\n                        }\n                        return item.getAsEntry();\n                    })\n                );\n            }\n            return $.Deferred().resolve(\n                $.makeArray(dataTransfer.files)\n            ).promise();\n        },\n\n        _getSingleFileInputFiles: function (fileInput) {\n            fileInput = $(fileInput);\n            var entries = fileInput.prop('webkitEntries') ||\n                    fileInput.prop('entries'),\n                files,\n                value;\n            if (entries && entries.length) {\n                return this._handleFileTreeEntries(entries);\n            }\n            files = $.makeArray(fileInput.prop('files'));\n            if (!files.length) {\n                value = fileInput.prop('value');\n                if (!value) {\n                    return $.Deferred().resolve([]).promise();\n                }\n                // If the files property is not available, the browser does not\n                // support the File API and we add a pseudo File object with\n                // the input value as name with path information removed:\n                files = [{name: value.replace(/^.*\\\\/, '')}];\n            } else if (files[0].name === undefined && files[0].fileName) {\n                // File normalization for Safari 4 and Firefox 3:\n                $.each(files, function (index, file) {\n                    file.name = file.fileName;\n                    file.size = file.fileSize;\n                });\n            }\n            return $.Deferred().resolve(files).promise();\n        },\n\n        _getFileInputFiles: function (fileInput) {\n            if (!(fileInput instanceof $) || fileInput.length === 1) {\n                return this._getSingleFileInputFiles(fileInput);\n            }\n            return $.when.apply(\n                $,\n                $.map(fileInput, this._getSingleFileInputFiles)\n            ).then(function () {\n                return Array.prototype.concat.apply(\n                    [],\n                    arguments\n                );\n            });\n        },\n\n        _onChange: function (e) {\n            var that = this,\n                data = {\n                    fileInput: $(e.target),\n                    form: $(e.target.form)\n                };\n            this._getFileInputFiles(data.fileInput).always(function (files) {\n                data.files = files;\n                if (that.options.replaceFileInput) {\n                    that._replaceFileInput(data);\n                }\n                if (that._trigger(\n                        'change',\n                        $.Event('change', {delegatedEvent: e}),\n                        data\n                    ) !== false) {\n                    that._onAdd(e, data);\n                }\n            });\n        },\n\n        _onPaste: function (e) {\n            var items = e.originalEvent && e.originalEvent.clipboardData &&\n                    e.originalEvent.clipboardData.items,\n                data = {files: []};\n            if (items && items.length) {\n                $.each(items, function (index, item) {\n                    var file = item.getAsFile && item.getAsFile();\n                    if (file) {\n                        data.files.push(file);\n                    }\n                });\n                if (this._trigger(\n                        'paste',\n                        $.Event('paste', {delegatedEvent: e}),\n                        data\n                    ) !== false) {\n                    this._onAdd(e, data);\n                }\n            }\n        },\n\n        _onDrop: function (e) {\n            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\n            var that = this,\n                dataTransfer = e.dataTransfer,\n                data = {};\n            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n                e.preventDefault();\n                this._getDroppedFiles(dataTransfer).always(function (files) {\n                    data.files = files;\n                    if (that._trigger(\n                            'drop',\n                            $.Event('drop', {delegatedEvent: e}),\n                            data\n                        ) !== false) {\n                        that._onAdd(e, data);\n                    }\n                });\n            }\n        },\n\n        _onDragOver: getDragHandler('dragover'),\n\n        _onDragEnter: getDragHandler('dragenter'),\n\n        _onDragLeave: getDragHandler('dragleave'),\n\n        _initEventHandlers: function () {\n            if (this._isXHRUpload(this.options)) {\n                this._on(this.options.dropZone, {\n                    dragover: this._onDragOver,\n                    drop: this._onDrop,\n                    // event.preventDefault() on dragenter is required for IE10+:\n                    dragenter: this._onDragEnter,\n                    // dragleave is not required, but added for completeness:\n                    dragleave: this._onDragLeave\n                });\n                this._on(this.options.pasteZone, {\n                    paste: this._onPaste\n                });\n            }\n            if ($.support.fileInput) {\n                this._on(this.options.fileInput, {\n                    change: this._onChange\n                });\n            }\n        },\n\n        _destroyEventHandlers: function () {\n            this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\n            this._off(this.options.pasteZone, 'paste');\n            this._off(this.options.fileInput, 'change');\n        },\n\n        _setOption: function (key, value) {\n            var reinit = $.inArray(key, this._specialOptions) !== -1;\n            if (reinit) {\n                this._destroyEventHandlers();\n            }\n            this._super(key, value);\n            if (reinit) {\n                this._initSpecialOptions();\n                this._initEventHandlers();\n            }\n        },\n\n        _initSpecialOptions: function () {\n            var options = this.options;\n            if (options.fileInput === undefined) {\n                options.fileInput = this.element.is('input[type=\"file\"]') ?\n                        this.element : this.element.find('input[type=\"file\"]');\n            } else if (!(options.fileInput instanceof $)) {\n                options.fileInput = $(options.fileInput);\n            }\n            if (!(options.dropZone instanceof $)) {\n                options.dropZone = $(options.dropZone);\n            }\n            if (!(options.pasteZone instanceof $)) {\n                options.pasteZone = $(options.pasteZone);\n            }\n        },\n\n        _getRegExp: function (str) {\n            var parts = str.split('/'),\n                modifiers = parts.pop();\n            parts.shift();\n            return new RegExp(parts.join('/'), modifiers);\n        },\n\n        _isRegExpOption: function (key, value) {\n            return key !== 'url' && $.type(value) === 'string' &&\n                /^\\/.*\\/[igm]{0,3}$/.test(value);\n        },\n\n        _initDataAttributes: function () {\n            var that = this,\n                options = this.options,\n                data = this.element.data();\n            // Initialize options set via HTML5 data-attributes:\n            $.each(\n                this.element[0].attributes,\n                function (index, attr) {\n                    var key = attr.name.toLowerCase(),\n                        value;\n                    if (/^data-/.test(key)) {\n                        // Convert hyphen-ated key to camelCase:\n                        key = key.slice(5).replace(/-[a-z]/g, function (str) {\n                            return str.charAt(1).toUpperCase();\n                        });\n                        value = data[key];\n                        if (that._isRegExpOption(key, value)) {\n                            value = that._getRegExp(value);\n                        }\n                        options[key] = value;\n                    }\n                }\n            );\n        },\n\n        _create: function () {\n            this._initDataAttributes();\n            this._initSpecialOptions();\n            this._slots = [];\n            this._sequence = this._getXHRPromise(true);\n            this._sending = this._active = 0;\n            this._initProgressObject(this);\n            this._initEventHandlers();\n        },\n\n        // This method is exposed to the widget API and allows to query\n        // the number of active uploads:\n        active: function () {\n            return this._active;\n        },\n\n        // This method is exposed to the widget API and allows to query\n        // the widget upload progress.\n        // It returns an object with loaded, total and bitrate properties\n        // for the running uploads:\n        progress: function () {\n            return this._progress;\n        },\n\n        // This method is exposed to the widget API and allows adding files\n        // using the fileupload API. The data parameter accepts an object which\n        // must have a files property and can contain additional options:\n        // .fileupload('add', {files: filesList});\n        add: function (data) {\n            var that = this;\n            if (!data || this.options.disabled) {\n                return;\n            }\n            if (data.fileInput && !data.files) {\n                this._getFileInputFiles(data.fileInput).always(function (files) {\n                    data.files = files;\n                    that._onAdd(null, data);\n                });\n            } else {\n                data.files = $.makeArray(data.files);\n                this._onAdd(null, data);\n            }\n        },\n\n        // This method is exposed to the widget API and allows sending files\n        // using the fileupload API. The data parameter accepts an object which\n        // must have a files or fileInput property and can contain additional options:\n        // .fileupload('send', {files: filesList});\n        // The method returns a Promise object for the file upload call.\n        send: function (data) {\n            if (data && !this.options.disabled) {\n                if (data.fileInput && !data.files) {\n                    var that = this,\n                        dfd = $.Deferred(),\n                        promise = dfd.promise(),\n                        jqXHR,\n                        aborted;\n                    promise.abort = function () {\n                        aborted = true;\n                        if (jqXHR) {\n                            return jqXHR.abort();\n                        }\n                        dfd.reject(null, 'abort', 'abort');\n                        return promise;\n                    };\n                    this._getFileInputFiles(data.fileInput).always(\n                        function (files) {\n                            if (aborted) {\n                                return;\n                            }\n                            if (!files.length) {\n                                dfd.reject();\n                                return;\n                            }\n                            data.files = files;\n                            jqXHR = that._onSend(null, data);\n                            jqXHR.then(\n                                function (result, textStatus, jqXHR) {\n                                    dfd.resolve(result, textStatus, jqXHR);\n                                },\n                                function (jqXHR, textStatus, errorThrown) {\n                                    dfd.reject(jqXHR, textStatus, errorThrown);\n                                }\n                            );\n                        }\n                    );\n                    return this._enhancePromise(promise);\n                }\n                data.files = $.makeArray(data.files);\n                if (data.files.length) {\n                    return this._onSend(null, data);\n                }\n            }\n            return this._getXHRPromise(false, data && data.context);\n        }\n\n    });\n\n}));\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/jquery.fileupload.js\n **/","/*! jQuery UI - v1.11.4+CommonJS - 2015-08-28\n* http://jqueryui.com\n* Includes: widget.js\n* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\n\n(function( factory ) {\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([ \"jquery\" ], factory );\n\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node/CommonJS\n\t\tfactory( require( \"jquery\" ) );\n\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}(function( $ ) {\n/*!\n * jQuery UI Widget 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n\n\nvar widget_uuid = 0,\n\twidget_slice = Array.prototype.slice;\n\n$.cleanData = (function( orig ) {\n\treturn function( elems ) {\n\t\tvar events, elem, i;\n\t\tfor ( i = 0; (elem = elems[i]) != null; i++ ) {\n\t\t\ttry {\n\n\t\t\t\t// Only trigger remove when necessary to save time\n\t\t\t\tevents = $._data( elem, \"events\" );\n\t\t\t\tif ( events && events.remove ) {\n\t\t\t\t\t$( elem ).triggerHandler( \"remove\" );\n\t\t\t\t}\n\n\t\t\t// http://bugs.jquery.com/ticket/8235\n\t\t\t} catch ( e ) {}\n\t\t}\n\t\torig( elems );\n\t};\n})( $.cleanData );\n\n$.widget = function( name, base, prototype ) {\n\tvar fullName, existingConstructor, constructor, basePrototype,\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\tproxiedPrototype = {},\n\t\tnamespace = name.split( \".\" )[ 0 ];\n\n\tname = name.split( \".\" )[ 1 ];\n\tfullName = namespace + \"-\" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\t// create selector for plugin\n\t$.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\n\t\treturn !!$.data( elem, fullName );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\texistingConstructor = $[ namespace ][ name ];\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\n\t\t// allow instantiation without \"new\" keyword\n\t\tif ( !this._createWidget ) {\n\t\t\treturn new constructor( options, element );\n\t\t}\n\n\t\t// allow instantiation without initializing for simple inheritance\n\t\t// must use \"new\" keyword (the code above always passes args)\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\t// extend with the existing constructor to carry over any static properties\n\t$.extend( constructor, existingConstructor, {\n\t\tversion: prototype.version,\n\t\t// copy the object used to create the prototype in case we need to\n\t\t// redefine the widget later\n\t\t_proto: $.extend( {}, prototype ),\n\t\t// track widgets that inherit from this widget in case this widget is\n\t\t// redefined after a widget inherits from it\n\t\t_childConstructors: []\n\t});\n\n\tbasePrototype = new base();\n\t// we need to make the options hash a property directly on the new instance\n\t// otherwise we'll modify the options hash on the prototype that we're\n\t// inheriting from\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\n\t$.each( prototype, function( prop, value ) {\n\t\tif ( !$.isFunction( value ) ) {\n\t\t\tproxiedPrototype[ prop ] = value;\n\t\t\treturn;\n\t\t}\n\t\tproxiedPrototype[ prop ] = (function() {\n\t\t\tvar _super = function() {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\n\t\t\t\t},\n\t\t\t\t_superApply = function( args ) {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\n\t\t\t\t};\n\t\t\treturn function() {\n\t\t\t\tvar __super = this._super,\n\t\t\t\t\t__superApply = this._superApply,\n\t\t\t\t\treturnValue;\n\n\t\t\t\tthis._super = _super;\n\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\treturnValue = value.apply( this, arguments );\n\n\t\t\t\tthis._super = __super;\n\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t})();\n\t});\n\tconstructor.prototype = $.widget.extend( basePrototype, {\n\t\t// TODO: remove support for widgetEventPrefix\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t// don't prefix for widgets that aren't DOM-based\n\t\twidgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n\t}, proxiedPrototype, {\n\t\tconstructor: constructor,\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetFullName: fullName\n\t});\n\n\t// If this widget is being redefined then we need to find all widgets that\n\t// are inheriting from it and redefine all of them so that they inherit from\n\t// the new version of this widget. We're essentially trying to replace one\n\t// level in the prototype chain.\n\tif ( existingConstructor ) {\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\n\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t$.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\n\t\t});\n\t\t// remove the list of existing child constructors from the old constructor\n\t\t// so the old child constructors can be garbage collected\n\t\tdelete existingConstructor._childConstructors;\n\t} else {\n\t\tbase._childConstructors.push( constructor );\n\t}\n\n\t$.widget.bridge( name, constructor );\n\n\treturn constructor;\n};\n\n$.widget.extend = function( target ) {\n\tvar input = widget_slice.call( arguments, 1 ),\n\t\tinputIndex = 0,\n\t\tinputLength = input.length,\n\t\tkey,\n\t\tvalue;\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\n\t\tfor ( key in input[ inputIndex ] ) {\n\t\t\tvalue = input[ inputIndex ][ key ];\n\t\t\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n\t\t\t\t// Clone objects\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\n\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend( {}, value );\n\t\t\t\t// Copy everything else by reference\n\t\t\t\t} else {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n$.widget.bridge = function( name, object ) {\n\tvar fullName = object.prototype.widgetFullName || name;\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === \"string\",\n\t\t\targs = widget_slice.call( arguments, 1 ),\n\t\t\treturnValue = this;\n\n\t\tif ( isMethodCall ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar methodValue,\n\t\t\t\t\tinstance = $.data( this, fullName );\n\t\t\t\tif ( options === \"instance\" ) {\n\t\t\t\t\treturnValue = instance;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\treturn $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\n\t\t\t\t\t\t\"attempted to call method '\" + options + \"'\" );\n\t\t\t\t}\n\t\t\t\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\n\t\t\t\t\treturn $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\n\t\t\t\t}\n\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\n\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\n\t\t\t\t\t\tmethodValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\n\t\t\t// Allow multiple hashes to be passed on init\n\t\t\tif ( args.length ) {\n\t\t\t\toptions = $.widget.extend.apply( null, [ options ].concat(args) );\n\t\t\t}\n\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, fullName );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} );\n\t\t\t\t\tif ( instance._init ) {\n\t\t\t\t\t\tinstance._init();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n\twidgetName: \"widget\",\n\twidgetEventPrefix: \"\",\n\tdefaultElement: \"<div>\",\n\toptions: {\n\t\tdisabled: false,\n\n\t\t// callbacks\n\t\tcreate: null\n\t},\n\t_createWidget: function( options, element ) {\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\n\t\tthis.element = $( element );\n\t\tthis.uuid = widget_uuid++;\n\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\n\n\t\tthis.bindings = $();\n\t\tthis.hoverable = $();\n\t\tthis.focusable = $();\n\n\t\tif ( element !== this ) {\n\t\t\t$.data( element, this.widgetFullName, this );\n\t\t\tthis._on( true, this.element, {\n\t\t\t\tremove: function( event ) {\n\t\t\t\t\tif ( event.target === element ) {\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.document = $( element.style ?\n\t\t\t\t// element within the document\n\t\t\t\telement.ownerDocument :\n\t\t\t\t// element is window or document\n\t\t\t\telement.document || element );\n\t\t\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n\t\t}\n\n\t\tthis.options = $.widget.extend( {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tthis._create();\n\t\tthis._trigger( \"create\", null, this._getCreateEventData() );\n\t\tthis._init();\n\t},\n\t_getCreateOptions: $.noop,\n\t_getCreateEventData: $.noop,\n\t_create: $.noop,\n\t_init: $.noop,\n\n\tdestroy: function() {\n\t\tthis._destroy();\n\t\t// we can probably remove the unbind calls in 2.0\n\t\t// all event bindings should go through this._on()\n\t\tthis.element\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeData( this.widgetFullName )\n\t\t\t// support: jquery <1.6.3\n\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t.removeData( $.camelCase( this.widgetFullName ) );\n\t\tthis.widget()\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeAttr( \"aria-disabled\" )\n\t\t\t.removeClass(\n\t\t\t\tthis.widgetFullName + \"-disabled \" +\n\t\t\t\t\"ui-state-disabled\" );\n\n\t\t// clean up events and states\n\t\tthis.bindings.unbind( this.eventNamespace );\n\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t},\n\t_destroy: $.noop,\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key,\n\t\t\tparts,\n\t\t\tcurOption,\n\t\t\ti;\n\n\t\tif ( arguments.length === 0 ) {\n\t\t\t// don't return a reference to the internal hash\n\t\t\treturn $.widget.extend( {}, this.options );\n\t\t}\n\n\t\tif ( typeof key === \"string\" ) {\n\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n\t\t\toptions = {};\n\t\t\tparts = key.split( \".\" );\n\t\t\tkey = parts.shift();\n\t\t\tif ( parts.length ) {\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\n\t\t\t\t}\n\t\t\t\tkey = parts.pop();\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\n\t\t\t\t}\n\t\t\t\tcurOption[ key ] = value;\n\t\t\t} else {\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\n\t\t\t\t}\n\t\t\t\toptions[ key ] = value;\n\t\t\t}\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\t_setOptions: function( options ) {\n\t\tvar key;\n\n\t\tfor ( key in options ) {\n\t\t\tthis._setOption( key, options[ key ] );\n\t\t}\n\n\t\treturn this;\n\t},\n\t_setOption: function( key, value ) {\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.widget()\n\t\t\t\t.toggleClass( this.widgetFullName + \"-disabled\", !!value );\n\n\t\t\t// If the widget is becoming disabled, then nothing is interactive\n\t\t\tif ( value ) {\n\t\t\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\t\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tenable: function() {\n\t\treturn this._setOptions({ disabled: false });\n\t},\n\tdisable: function() {\n\t\treturn this._setOptions({ disabled: true });\n\t},\n\n\t_on: function( suppressDisabledCheck, element, handlers ) {\n\t\tvar delegateElement,\n\t\t\tinstance = this;\n\n\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\tif ( typeof suppressDisabledCheck !== \"boolean\" ) {\n\t\t\thandlers = element;\n\t\t\telement = suppressDisabledCheck;\n\t\t\tsuppressDisabledCheck = false;\n\t\t}\n\n\t\t// no element argument, shuffle and use this.element\n\t\tif ( !handlers ) {\n\t\t\thandlers = element;\n\t\t\telement = this.element;\n\t\t\tdelegateElement = this.widget();\n\t\t} else {\n\t\t\telement = delegateElement = $( element );\n\t\t\tthis.bindings = this.bindings.add( element );\n\t\t}\n\n\t\t$.each( handlers, function( event, handler ) {\n\t\t\tfunction handlerProxy() {\n\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\tif ( !suppressDisabledCheck &&\n\t\t\t\t\t\t( instance.options.disabled === true ||\n\t\t\t\t\t\t\t$( this ).hasClass( \"ui-state-disabled\" ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t\t.apply( instance, arguments );\n\t\t\t}\n\n\t\t\t// copy the guid so direct unbinding works\n\t\t\tif ( typeof handler !== \"string\" ) {\n\t\t\t\thandlerProxy.guid = handler.guid =\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\n\t\t\t}\n\n\t\t\tvar match = event.match( /^([\\w:-]*)\\s*(.*)$/ ),\n\t\t\t\teventName = match[1] + instance.eventNamespace,\n\t\t\t\tselector = match[2];\n\t\t\tif ( selector ) {\n\t\t\t\tdelegateElement.delegate( selector, eventName, handlerProxy );\n\t\t\t} else {\n\t\t\t\telement.bind( eventName, handlerProxy );\n\t\t\t}\n\t\t});\n\t},\n\n\t_off: function( element, eventName ) {\n\t\teventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) +\n\t\t\tthis.eventNamespace;\n\t\telement.unbind( eventName ).undelegate( eventName );\n\n\t\t// Clear the stack to avoid memory leaks (#10056)\n\t\tthis.bindings = $( this.bindings.not( element ).get() );\n\t\tthis.focusable = $( this.focusable.not( element ).get() );\n\t\tthis.hoverable = $( this.hoverable.not( element ).get() );\n\t},\n\n\t_delay: function( handler, delay ) {\n\t\tfunction handlerProxy() {\n\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t.apply( instance, arguments );\n\t\t}\n\t\tvar instance = this;\n\t\treturn setTimeout( handlerProxy, delay || 0 );\n\t},\n\n\t_hoverable: function( element ) {\n\t\tthis.hoverable = this.hoverable.add( element );\n\t\tthis._on( element, {\n\t\t\tmouseenter: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-hover\" );\n\t\t\t},\n\t\t\tmouseleave: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-hover\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_focusable: function( element ) {\n\t\tthis.focusable = this.focusable.add( element );\n\t\tthis._on( element, {\n\t\t\tfocusin: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-focus\" );\n\t\t\t},\n\t\t\tfocusout: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar prop, orig,\n\t\t\tcallback = this.options[ type ];\n\n\t\tdata = data || {};\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\t\t// the original event may come from any element\n\t\t// so we need to reset the target on the new event\n\t\tevent.target = this.element[ 0 ];\n\n\t\t// copy original event properties over to the new event\n\t\torig = event.originalEvent;\n\t\tif ( orig ) {\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tif ( !( prop in event ) ) {\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\t\treturn !( $.isFunction( callback ) &&\n\t\t\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\n\t$.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\n\t\tif ( typeof options === \"string\" ) {\n\t\t\toptions = { effect: options };\n\t\t}\n\t\tvar hasOptions,\n\t\t\teffectName = !options ?\n\t\t\t\tmethod :\n\t\t\t\toptions === true || typeof options === \"number\" ?\n\t\t\t\t\tdefaultEffect :\n\t\t\t\t\toptions.effect || defaultEffect;\n\t\toptions = options || {};\n\t\tif ( typeof options === \"number\" ) {\n\t\t\toptions = { duration: options };\n\t\t}\n\t\thasOptions = !$.isEmptyObject( options );\n\t\toptions.complete = callback;\n\t\tif ( options.delay ) {\n\t\t\telement.delay( options.delay );\n\t\t}\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n\t\t\telement[ method ]( options );\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\n\t\t} else {\n\t\t\telement.queue(function( next ) {\n\t\t\t\t$( this )[ method ]();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback.call( element[ 0 ] );\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t};\n});\n\nvar widget = $.widget;\n\n\n\n}));\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/vendor/jquery.ui.widget.js\n **/"],"sourceRoot":""}